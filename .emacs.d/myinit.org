#+STARTUP: overview
#+TITLE: Emacs Configuration
#+AUTHOR: Vinodh MJ Human
#+EMAIL: 
#+OPTIONS: toc:nil num:nil

* Pre-requisites
I've stolen many a configuration from Mike Zamansky and Harry R Schwartz
#+BEGIN_SRC emacs-lisp

;; INSTALL PACKAGES
;; --------------------------------------

; start package.el with emacs
(require 'package)
(setq package-enable-at-startup nil)

; add MELPA to repository list
(setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")))

; initialize package.el
(package-initialize)

;; Bootstrap `use-package'
(unless (package-installed-p 'use-package)
	(package-refresh-contents)
	(package-install 'use-package))

(setq use-package-verbose t)
(setq use-package-always-ensure t)

(set-default-coding-systems 'utf-8)
(prefer-coding-system 'utf-8)

;;Install paradox package manager
(use-package paradox
:ensure t)

;; set browser to firefox
(setq browse-url-browser-function 'browse-url-chromium)

#+END_SRC

* Stolen from hrs
** General
#+BEGIN_SRC emacs-lisp
(defun vmj/view-buffer-name ()
    "Display the filename of the current buffer."
    (interactive)
    (message (buffer-file-name)))

(defun vmj/generate-scratch-buffer ()
    "Create and switch to a temporary scratch buffer with a random
       name."
    (interactive)
    (switch-to-buffer (make-temp-name "scratch-")))

(defun vmj/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

(defun vmj/copy-file-line-matlab ()
      "Copy current file path and line number to clipboard and trim till matlabroot"
    (interactive)
    (let (fpln)
      (setq fpln (concatenate 'string (buffer-file-name) ":" (number-to-string (line-number-at-pos))))
      (setq fpln (split-string fpln "/matlab/"))
      (setq fpln (car (last fpln)))
      (kill-new fpln)
      (message (concat fpln " copied to clipboard"))))

#+END_SRC
** Frame title
The default frame title isn't useful. This binds it to the name of the current
project:

#+BEGIN_SRC emacs-lisp
;  (setq frame-title-format '((:eval (projectile-project-name))))
#+END_SRC

** Use fancy lambdas

Why not?

#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode t)
#+END_SRC

** Hide certain modes from the modeline

I'd rather have only a few necessary mode identifiers on my modeline. This
either hides or "renames" a variety of major or minor modes using the =diminish=
package.

#+BEGIN_SRC emacs-lisp
  (defmacro diminish-minor-mode (filename mode &optional abbrev)
    `(eval-after-load (symbol-name ,filename)
       '(diminish ,mode ,abbrev)))

  (defmacro diminish-major-mode (mode-hook abbrev)
    `(add-hook ,mode-hook
               (lambda () (setq mode-name ,abbrev))))

  (diminish-minor-mode 'abbrev 'abbrev-mode)
  (diminish-minor-mode 'simple 'auto-fill-function)
  (diminish-minor-mode 'company 'company-mode)
  (diminish-minor-mode 'eldoc 'eldoc-mode)
  (diminish-minor-mode 'flycheck 'flycheck-mode)
  (diminish-minor-mode 'flyspell 'flyspell-mode)
  (diminish-minor-mode 'global-whitespace 'global-whitespace-mode)
  (diminish-minor-mode 'projectile 'projectile-mode)
  (diminish-minor-mode 'ruby-end 'ruby-end-mode)
  (diminish-minor-mode 'subword 'subword-mode)
  (diminish-minor-mode 'undo-tree 'undo-tree-mode)
  (diminish-minor-mode 'yard-mode 'yard-mode)
  (diminish-minor-mode 'yasnippet 'yas-minor-mode)
  (diminish-minor-mode 'wrap-region 'wrap-region-mode)

  (diminish-minor-mode 'paredit 'paredit-mode " π")

  (diminish-major-mode 'emacs-lisp-mode-hook "el")
  (diminish-major-mode 'haskell-mode-hook "λ=")
  (diminish-major-mode 'lisp-interaction-mode-hook "λ")
  (diminish-major-mode 'python-mode-hook "Py")
#+END_SRC
* Interface tweaks
** Start up
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
  (tool-bar-mode -1)
  (fset 'yes-or-no-p 'y-or-n-p)
  (global-linum-mode t) ;; enable line numbers globally
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
  (setq ivy-use-virtual-buffers t)
  (defun jump-to-next-newline()
  "Move to the end of the line and return"
  (interactive)
  (move-end-of-line)
  (newline))
  (setq ivy-format-function 'ivy-format-function-line)
  (setq ivy-display-style 'fancy)
;;(setq view-read-only t)
 
#+END_SRC

** Ace windows for easy window switching
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
  :ensure t
  :init
  (progn
  (setq aw-scope 'frame)
  (global-set-key (kbd "C-x O") 'other-frame)
    (global-set-key [remap other-window] 'ace-window)
    (custom-set-faces
     '(aw-leading-char-face
       ((t (:inherit ace-jump-face-foreground :height 3.0))))) 
    ))

(defun swap-window()
"Swap windows and leave focus on the original window"
(interactive)
(ace-swap-window)
(aw-flip-window))

#+END_SRC

#+RESULTS:

** Themes and modeline:
#+BEGIN_SRC emacs-lisp
(use-package moe-theme
:ensure t)

(use-package powerline
:ensure t
:config
(powerline-moe-theme)
(setq moe-theme-highlight-buffer-id t)
)
(set-frame-font "DejaVu Sans Mono 11" nil t)
(add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono 11"))
#+END_SRC

#+RESULTS:
: t 
** Custom solarized-dark theme

I like the solarized-dark theme. I prefer keeping all the characters in the same
side and font, though.

#+BEGIN_SRC emacs-lisp
  (defun vmj/apply-solarized-theme ()
    (setq solarized-use-variable-pitch nil)
    (setq solarized-height-plus-1 1.0)
    (setq solarized-height-plus-2 1.0)
    (setq solarized-height-plus-3 1.0)
    (setq solarized-height-plus-4 1.0)
    (setq solarized-high-contrast-mode-line t)
    (load-theme 'solarized-dark t))
#+END_SRC

If this code is being evaluated by =emacs --daemon=, ensure that each subsequent
frame is themed appropriately.

#+BEGIN_SRC emacs-lisp
  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame)
                    (vmj/apply-solarized-theme)))
    (vmj/apply-solarized-theme))
#+END_SRC
* Org mode
** org bullets
Org bullets makes things look pretty

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
:ensure t
:config
(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

;;I like seeing a little downward-pointing arrow instead of the usual ellipsis (...) that org displays when there’s stuff under a header.
(setq org-ellipsis "⤵")

;; Use syntax highlighting in source blocks while editing.
(setq org-src-fontify-natively t)

;; Make TAB act as if it were issued in a buffer of the language’s major mode.
(setq org-src-tab-acts-natively t)

;; When editing a code snippet, use the current window rather than popping open a new one (which shows the same information).
(setq org-src-window-setup 'current-window)

;; Quickly insert a block of elisp:
(add-to-list 'org-structure-template-alist
             '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))

;; Enable spell-checking in Org-mode.
(add-hook 'org-mode-hook 'flyspell-mode)

#+END_SRC
** org custom variables
#+BEGIN_SRC emacs-lisp
(custom-set-variables
'(org-directory "~/Dropbox/orgfiles")
'(org-default-notes-file (concat org-directory "/notes.org"))
'(org-export-html-postamble nil)
'(org-hide-leading-stars t)
'(org-startup-folded (quote overview))
'(org-startup-indented t)
)

(setq org-file-apps
(append '(
("\\.pdf\\'" . "evince %s")
) org-file-apps ))

#+END_SRC
** org agenda
#+BEGIN_SRC emacs-lisp

;;scheduling 
(global-set-key "\C-ca" 'org-agenda)

(setq org-agenda-custom-commands
'(("c" "Simple agenda view"
((agenda "")
(alltodo "")))))

#+END_SRC
** org ac
#+BEGIN_SRC emacs-lisp

(use-package org-ac
:ensure t
:init (progn
(require 'org-ac)
(org-ac/config-default)
))

(add-to-list 'ac-modes 'org-mode)

#+END_SRC
** org capture
#+BEGIN_SRC emacs-lisp

(global-set-key (kbd "C-c c") 'org-capture)

            (setq org-agenda-files (list "~/Dropbox/orgfiles/i.org"
          			       "~/Dropbox/orgfiles/y.org"
          			       "~/Dropbox/orgfiles/word.org"))

            (setq org-capture-templates
          			  '(("a" "Appointment" entry (file  "~/Dropbox/orgfiles/gcal.org" )
          				   "* %?\n\n%^T\n\n:PROPERTIES:\n\n:END:\n\n")
          				  ("l" "Link" entry (file+headline "~/Dropbox/orgfiles/links.org" "Links")
          				   "* %? %^L" :prepend t)
          				  ("b" "Blog idea" entry (file+headline "~/Dropbox/orgfiles/y.org" "Blog Topics:")
          				   "* %?\n" :prepend t)
                                        ("y" "Youtube idea" entry (file+headline "~/Dropbox/orgfiles/y.org" "Youtube Topics:")
          				   "* %?\n" :prepend t)
          				  ("t" "To Do Item" entry (file+headline "~/Dropbox/orgfiles/i.org" "To Do")
          				   "* TODO %? \n%u" :prepend t)
  					  ("d" "Detailed To Do Item" entry (file+headline "~/Dropbox/orgfiles/i.org" "To Do")
          				   "* TODO %^C %? %^g\n%u" :prepend t)
  					  ("n" "Note" entry (file+headline "~/Dropbox/orgfiles/i.org" "Notes")
          				   "* %?\n%u" :prepend t)
  					  ("w" "Word" entry (file+headline "~/Dropbox/orgfiles/word.org" "Words")
          				   "* %?\n" :prepend t)
  					  ("p" "Phrase" entry (file+headline "~/Dropbox/orgfiles/word.org" "Phrases")
          				   "* %?\n" :prepend t)
  					  ))
#+END_SRC

** org mobile   
#+BEGIN_SRC emacs-lisp        
;; Set to the name of the file where new notes will be stored
(setq org-mobile-inbox-for-pull "~/Dropbox/orgfiles/mobile.org")
;; Set to <your Dropbox root directory>/MobileOrg.
(setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
;;(run-with-idle-timer 360 1 'org-mobile-pull)
;;(run-with-idle-timer 300 1 'org-mobile-push)

#+END_SRC

#+RESULTS:
: [nil 0 300 0 1 org-mobile-push nil idle 0]

** org refile
#+BEGIN_SRC emacs-lisp

(setq org-refile-targets '((org-agenda-files :maxlevel . 1)))
(setq org-refile-use-outline-path 'file)
(setq org-outline-path-complete-in-steps nil)
#+END_SRC

** org other stuff
#+BEGIN_SRC emacs-lisp

  (defadvice org-capture-finalize 
              (after delete-capture-frame activate)  
          "Advise capture-finalize to close the frame"  
          (if (equal "capture" (frame-parameter nil 'name))  
          (delete-frame)))

          (defadvice org-capture-destroy 
              (after delete-capture-frame activate)  
          "Advise capture-destroy to close the frame"  
          (if (equal "capture" (frame-parameter nil 'name))  
          (delete-frame)))  

          (use-package noflet
          :ensure t )
          (defun make-capture-frame ()
          "Create a new frame and run org-capture."
          (interactive)
          (make-frame '((name . "capture")))
          (select-frame-by-name "capture")
          (delete-other-windows)
          (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
              (org-capture)))

  (require 'ox-md)
  (require 'ox-beamer)

  ;; Don’t ask before evaluating code blocks.
  (setq org-confirm-babel-evaluate nil)

  ;(use-package epresent
  ;:ensure t)

#+END_SRC

#+RESULTS:
: make-capture-frame
** org align, justify
#+BEGIN_SRC emacs-lisp

(add-hook 'org-mode-hook '(lambda () (setq fill-column 80)))
(add-hook 'org-mode-hook 'turn-on-auto-fill)

(add-hook 'text-mode-hook 'turn-on-auto-fill)
(add-hook 'text-mode-hook '(lambda() (set-fill-column 80)))
#+END_SRC
** org  colors
#+BEGIN_SRC emacs-lisp
    (set-face-foreground 'org-link "MistyRose4")
#+END_SRC
* smex
#+BEGIN_SRC emacs-lisp

   (use-package smex
   :ensure t
   :config 
   (global-set-key (kbd "M-x") 'smex)
   (global-set-key (kbd "M-X") 'smex-major-mode-commands)
   ;; This is your old M-x.
  (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command))
#+END_SRC

#+RESULTS:
: t
* abo-abo
** Swiper / Ivy / Counsel
Swiper gives us a really efficient incremental search with regular expressions
and Ivy / Counsel replace a lot of ido or helms completion functionality
#+BEGIN_SRC emacs-lisp
  (use-package counsel
   :ensure t
   :bind
   (("M-y" . counsel-yank-pop)
   :map ivy-minibuffer-map
   ("M-y" . ivy-next-line)))

  (use-package ivy
  :ensure t
  :diminish (ivy-mode)
  :bind (("C-x b" . ivy-switch-buffer))
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers t)
  (setq ivy-display-style 'fancy)
  (setq ivy-height 20)
  (setq ivy-format-function 'ivy-format-function-line))

  (use-package swiper
  :ensure t
  :bind (("C-s" . swiper)
	 ("C-r" . swiper)
	 ("C-c C-r" . ivy-resume)
	 ("M-x" . counsel-M-x)
       ("C-x r b" . counsel-bookmark)
	 ("C-x C-f" . counsel-find-file))
  :config
  (progn
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-display-style 'fancy)
    (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
    ))

(defface ivy-current-match
  '((((class color) (background light))
     :background "#1a4b77" :foreground "white")
    (((class color) (background dark))
     :background "#65a7e2" :foreground "black"))
  "Face used by Ivy for highlighting first match.")

#+END_SRC

#+RESULTS:
: ivy-current-match

** Avy
navigate by searching for a letter on the screen and jumping to it
See https://github.com/abo-abo/avy for more info
#+BEGIN_SRC emacs-lisp
  (use-package avy
  :ensure t
  :bind ("M-s" . avy-goto-word-1)) ;; changed from char as per jcs
#+END_SRC
** Hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra 
    :ensure hydra
    :init 
    (global-set-key
    (kbd "C-x t")
	    (defhydra toggle (:color blue)
	      "toggle"
	      ("a" abbrev-mode "abbrev")
	      ("s" flyspell-mode "flyspell")
	      ("d" toggle-debug-on-error "debug")
	      ("c" fci-mode "fCi")
	      ("f" auto-fill-mode "fill")
	      ("t" toggle-truncate-lines "truncate")
	      ("w" whitespace-mode "whitespace")
	      ("c" flycheck-mode "flycheck")
	      ("q" nil "cancel")))
    (global-set-key
     (kbd "C-x j")
     (defhydra gotoline 
       ( :pre (linum-mode 1)
	      :post (linum-mode -1))
       "goto"
       ("t" (lambda () (interactive)(move-to-window-line-top-bottom 0)) "top")
       ("b" (lambda () (interactive)(move-to-window-line-top-bottom -1)) "bottom")
       ("m" (lambda () (interactive)(move-to-window-line-top-bottom)) "middle")
       ("e" (lambda () (interactive)(end-of-buffer)) "end")
       ("c" recenter-top-bottom "recenter")
       ("n" next-line "down")
       ("p" (lambda () (interactive) (forward-line -1))  "up")
       ("g" goto-line "goto-line")
       ))
    (global-set-key
     (kbd "C-c t")
     (defhydra hydra-global-org (:color blue)
       "Org"
       ("t" org-timer-start "Start Timer")
       ("s" org-timer-stop "Stop Timer")
       ("r" org-timer-set-timer "Set Timer") ; This one requires you be in an orgmode doc, as it sets the timer for the header
       ("p" org-timer "Print Timer") ; output timer value to buffer
       ("w" (org-clock-in '(4)) "Clock-In") ; used with (org-clock-persistence-insinuate) (setq org-clock-persist t)
       ("o" org-clock-out "Clock-Out") ; you might also want (setq org-log-note-clock-out t)
       ("j" org-clock-goto "Clock Goto") ; global visit the clocked task
       ("c" org-capture "Capture") ; Don't forget to define the captures you want http://orgmode.org/manual/Capture.html
	     ("l" (or )rg-capture-goto-last-stored "Last Capture"))))

(global-set-key
     (kbd "C-x f")
     (defhydra frequent (:color blue)
       "frequent"
       ("f" counsel-find-file "find-file")
       ("l" mlint-clear-warnings "mlint clear")
       ("b" counsel-bookmark "bookmarks")
       ("a" mark-whole-buffer "select all")
       ("r" revert-buffer "refresh")
       ("p" crepro "projectile")
       ("s" (find-file "/local-ssd/vjayakri") "ssd")
       ("n" (find-file "/mathworks/devel/sandbox/vjayakri") "sbs")
       ("w" auto-fill-mode "auto wrap")
       ("g" (find-file "~/projects/cpp/graph") "graph")
       ("v" peep-dired "peep view")
       ("c" bvmj/copy-file-line-matlab "copy file line to clipboard")
       ("h" hs-org/minor-mode "hideshow")))
     
#+END_SRC

#+RESULTS:
: frequent/body
* Necessary
** Misc packages
#+BEGIN_SRC emacs-lisp

  ; Highlights the current cursor line
  (when window-system
  (global-hl-line-mode))
  
  ; flashes the cursor's line when you scroll
  (use-package beacon
  :ensure t
  :config
  (beacon-mode 1)
  ; (setq beacon-color "#666600")
  )
  
  ; deletes all the whitespace when you hit backspace or delete
  (use-package hungry-delete
  :ensure t
  :config
  (global-hungry-delete-mode))
  
  ; expand the marked region in semantic increments (negative prefix to reduce region)
  (use-package expand-region
  :ensure t
  :config 
  (global-set-key (kbd "C-=") 'er/expand-region))

  (setq save-interprogram-paste-before-kill t)

  ; font scaling
  (use-package default-text-scale
  :ensure t
  :config
  (global-set-key (kbd "C-M-=") 'default-text-scale-increase)
  (global-set-key (kbd "C-M--") 'default-text-scale-decrease))

  ;origami folding
  (use-package origami
  :ensure t)

  (use-package which-key
	:ensure t 
	:config
	(which-key-mode))

#+END_SRC
** Autocomplete
#+BEGIN_SRC emacs-lisp
  (use-package auto-complete
  :ensure t
  :init
  (progn
    (ac-config-default)
    (global-auto-complete-mode t)
    (add-to-list 'ac-modes 'matlab-mode)
    (add-to-list 'ac-modes 'nxml-mode)
    ))
#+END_SRC
  
** Flycheck
#+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :ensure t
      :init
      (global-flycheck-mode t))

(add-hook 'c++-mode-hook (lambda () (setq flycheck-gcc-language-standard "c++11")))
(add-hook 'c++-mode-hook (lambda () (setq flycheck-clang-language-standard "c++11")))
;(add-hook 'text-mode-hook 'flyspell-mode)
;(add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+END_SRC

#+RESULTS:
| (lambda nil (setq flycheck-clang-language-standard c++11)) | (lambda nil (setq flycheck-gcc-language-standard c++11)) | irony-mode | er/add-cc-mode-expansions | (lambda nil (sb-rtags--menu-adds C++)) | (lambda nil (easy-menu-add-item nil (quote (C++)) (rtags-submenu-list))) |

** Yasnippet
#+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :ensure t
      :init
        (yas-global-mode 1))

(use-package yasnippet-snippets
:ensure t)

#+END_SRC

#+RESULTS:

** Undo Tree
#+BEGIN_SRC emacs-lisp
    (use-package undo-tree
      :ensure t
      :init
      (global-undo-tree-mode))
#+END_SRC
** Reveal.js
#+BEGIN_SRC emacs-lisp
    (use-package ox-reveal
    :ensure ox-reveal)

    (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
    (setq org-reveal-mathjax t)

    (use-package htmlize
    :ensure t)
#+END_SRC

#+RESULTS:
: t

** iedit and narrow / widen dwim

#+BEGIN_SRC emacs-lisp
  ; mark and edit all copies of the marked region simultaneously. 
  (use-package iedit
  :ensure t)
  
  ; if you're windened, narrow to the region, if you're narrowed, widen
  ; bound to C-x n
  (defun narrow-or-widen-dwim (p)
  "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
  Intelligently means: region, org-src-block, org-subtree, or defun,
  whichever applies first.
  Narrowing to org-src-block actually calls `org-edit-src-code'.
  
  With prefix P, don't widen, just narrow even if buffer is already
  narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
  ((region-active-p)
  (narrow-to-region (region-beginning) (region-end)))
  ((derived-mode-p 'org-mode)
  ;; `org-edit-src-code' is not a real narrowing command.
  ;; Remove this first conditional if you don't want it.
  (cond ((ignore-errors (org-edit-src-code))
  (delete-other-windows))
  ((org-at-block-p)
  (org-narrow-to-block))
  (t (org-narrow-to-subtree))))
  (t (narrow-to-defun))))
  
  ;; (define-key endless/toggle-map "n" #'narrow-or-widen-dwim)
  ;; This line actually replaces Emacs' entire narrowing keymap, that's
  ;; how much I like this command. Only copy it if that's what you want.
  (define-key ctl-x-map "n" #'narrow-or-widen-dwim)
  
#+END_SRC


#+RESULTS:
: narrow-or-widen-dwim
** Dired
  #+BEGIN_SRC emacs-lisp
      (use-package dired+
      :ensure t
      :config (require 'dired+)
      )
      (use-package dired-quick-sort
      :ensure t
      :config
      (dired-quick-sort-setup))

    (use-package peep-dired
      :ensure t
      :defer t ; don't access `dired-mode-map' until `peep-dired' is loaded
      :bind (:map dired-mode-map
                  ("P" . peep-dired))
      :config
      (setq peep-dired-cleanup-on-disable t)
      (setq peep-dired-enable-on-directories t)
      (setq peep-dired-ignored-extensions '("mkv" "iso" "mp4" "slx" "mdl")))


     ; copy to the other open dired buffer
    (setq dired-listing-switches "-al --group-directories-first")

    (setq dired-dwim-target t)
    (setq dired-recursive-copies 'always)


    (set-face-foreground 'diredp-dir-name "IndianRed")
    (set-face-foreground 'diredp-file-name "gray")
    (set-face-foreground 'diredp-ignored-file-name "dim gray")
    (set-face-foreground 'diredp-file-suffix "dark cyan")
    (set-face-background 'diredp-dir-name "#002b36")

(setq dired-dwim-target t)
(setq dired-recursive-copies 'always)
  #+END_SRC

  #+RESULTS:
  : always

** Ibuffer
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
   (setq ibuffer-saved-filter-groups
	 (quote (("default"
                  ("dired" (mode . dired-mode))
		  ("org" (name . "^.*org$"))
                
		  ("web" (or (mode . web-mode) (mode . js2-mode)))
		  ("shell" (or (mode . eshell-mode) (mode . shell-mode)))
		  ("programming" (or
				  (mode . python-mode)
		                  (mode . matlab-mode)
				  (mode . c++-mode)))

                                ("emacs" (or
                            (name . "^\\*scratch\\*$")
                            (name . "^\\*Messages\\*$")))
				  ))))
   (add-hook 'ibuffer-mode-hook
             (lambda ()
               (ibuffer-switch-to-saved-filter-groups "default")))
               

#+END_SRC
* Programming essentials
** Babel

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
'org-babel-load-languages
'((python . t)
   (emacs-lisp . t)
   (C . t)
(js . t)
   (ditaa . t)
   (dot . t)
   (org . t)
      (sh . t )
   (shell . t )
(latex . t )
   ))
#+END_SRC
** Projectile
#+BEGIN_SRC emacs-lisp
    ;;  Projectile
      (use-package projectile
      :ensure t
      :config
      (projectile-global-mode)
      (setq projectile-mode-line
      '(:eval (format " Projectile[%s(%s)]"
      (projectile-project-name))))
      (setq projectile-completion-system 'ivy))

      (use-package counsel-projectile
      :ensure t
      )

#+END_SRC

#+RESULTS:
: t

** Smart Parens
#+BEGIN_SRC emacs-lisp
(use-package smartparens
:ensure t
:config
(smartparens-global-mode t)
(show-smartparens-global-mode t)
:bind
( ("C-<down>" . sp-down-sexp)
 ("C-<up>"   . sp-up-sexp)
 ("M-<down>" . sp-backward-down-sexp)
 ("M-<up>"   . sp-backward-up-sexp)
("C-M-a" . sp-beginning-of-sexp)
 ("C-M-e" . sp-end-of-sexp)



 ("C-M-f" . sp-forward-sexp)
 ("C-M-b" . sp-backward-sexp)

 ("C-M-n" . sp-next-sexp)
 ("C-M-p" . sp-previous-sexp)

 ("C-S-f" . sp-forward-symbol)
 ("C-S-b" . sp-backward-symbol)

 ("C-<right>" . sp-forward-slurp-sexp)
 ("M-<right>" . sp-forward-barf-sexp)
 ("C-<left>"  . sp-backward-slurp-sexp)
 ("M-<left>"  . sp-backward-barf-sexp)

 ("C-M-t" . sp-transpose-sexp)
 ("C-M-k" . sp-kill-sexp)
 ("C-k"   . sp-kill-hybrid-sexp)
 ("M-k"   . sp-backward-kill-sexp)
 ("C-M-w" . sp-copy-sexp)

 ("C-M-d" . delete-sexp)

 ("M-<backspace>" . backward-kill-word)
 ("C-<backspace>" . sp-backward-kill-word)
 ([remap sp-backward-kill-word] . backward-kill-word)

 ("M-[" . sp-backward-unwrap-sexp)
 ("M-]" . sp-unwrap-sexp)

 ("C-x C-t" . sp-transpose-hybrid-sexp)

 ("C-c ("  . wrap-with-parens)
 ("C-c ["  . wrap-with-brackets)
 ("C-c {"  . wrap-with-braces)
 ("C-c '"  . wrap-with-single-quotes)
 ("C-c \"" . wrap-with-double-quotes)
 ("C-c _"  . wrap-with-underscores)
("C-c `"  . wrap-with-back-quotes)
))


#+END_SRC

#+RESULTS:
: wrap-with-back-quotes

** Magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind ("C-x g" . magit-status)
  :config
  (setq git-commit-summary-max-length 50)
  (add-hook 'git-commit-mode-hook 'turn-on-flyspell))

#+END_SRC
** LaTeX
#+BEGIN_SRC emacs-lisp

;; latex
;(use-package tex
;:ensure auctex)

;(defun tex-view ()
;    (interactive)
;    (tex-send-command "evince" (tex-append tex-print-file ".pdf")))
#+END_SRC
** irony
#+BEGIN_SRC emacs-lisp
;; == irony-mode ==

(add-hook 'after-init-hook 'global-company-mode)

(use-package irony
  :ensure t
  :defer t
  :init
  (add-hook 'c++-mode-hook 'irony-mode)
  (add-hook 'c-mode-hook 'irony-mode)
  (add-hook 'objc-mode-hook 'irony-mode)
  :config
  ;; replace the `completion-at-point' and `complete-symbol' bindings in
  ;; irony-mode's buffers by irony-mode's function
  (defun my-irony-mode-hook ()
    (define-key irony-mode-map [remap completion-at-point]
      'irony-completion-at-point-async)
    (define-key irony-mode-map [remap complete-symbol]
      'irony-completion-at-point-async))
  (add-hook 'irony-mode-hook 'my-irony-mode-hook)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
  )

;; == company-mode ==
(use-package company
  :ensure t
  :defer t
  :init (add-hook 'after-init-hook 'global-company-mode)
  :config
  (use-package company-irony :ensure t :defer t)
  (setq company-idle-delay              nil
	company-minimum-prefix-length   2
	company-show-numbers            t
	company-tooltip-limit           20
	company-dabbrev-downcase        nil
	company-backends                '((company-irony company-gtags))
	)
  )

(global-set-key (kbd "M-RET") 'company-complete)

#+END_SRC

#+RESULTS:
: company-complete
** hideshow
#+BEGIN_SRC emacs-lisp
(use-package hideshow
    :ensure t)

#+END_SRC

#+RESULTS:
** find other file
#+BEGIN_SRC emacs-lisp
    ; Non-nil means ignore cases in matches (see `case-fold-search').
    ; If you have extensions in different cases, you will want this to be nil.
    (setq ff-case-fold-search "on")

    (setq ff-always-in-other-window "on")

    ; If non-nil, always attempt to create the other file if it was not found.
    (setq ff-always-try-to-create nil)

    ;;   If non-nil, ignores #include lines.
    (setq ff-ignore-include "on")

    ; ff-quiet-mode
    ;  If non-nil, traces which directories are being searched.

    ;;   A list of regular expressions specifying how to recognize special
    ;;   constructs such as include files etc, and an associated method for
    ;;   extracting the filename from that construct.
    ;; - ff-special-constructs'

    ;      Alist of extensions to find given the current file's extension.
    (defvar my-cpp-other-file-alist
    '(("\\.cpp\\'" (".hpp" ".ipp"))
      ("\\.ipp\\'" (".hpp" ".cpp"))
      ("\\.hpp\\'" (".ipp" ".cpp"))
      ("\\.cxx\\'" (".hxx" ".ixx"))
      ("\\.ixx\\'" (".cxx" ".hxx"))
      ("\\.hxx\\'" (".ixx" ".cxx"))
      ("\\.c\\'" (".h"))
      ("\\.h\\'" (".c"))
      ))

    (setq-default ff-other-file-alist 'my-cpp-other-file-alist)

  (setq ff-search-directories '("." "./../export/include/*/*" "./export/include/*/*" "./include/*"))
  (setq cc-search-directories '("." "./../export/include/*/*" "./export/include/*/*" "./include/*"))
           ;    List of directories searched through with each extension specified in
            ;   `ff-other-file-alist' that matches this file's extension.


             ;; - `ff-pre-find-hook'
             ;;   List of functions to be called before the search for the file starts.

             ;; - `ff-pre-load-hook'
             ;;   List of functions to be called before the other file is loaded.

             ;; - `ff-post-load-hook'
             ;;   List of functions to be called after the other file is loaded.

             ;; - `ff-not-found-hook'
             ;;   List of functions to be called if the other file could not be found.

             ;; - `ff-file-created-hook'
             ;;   List of functions to be called if the other file has been created.




        (define-key c-mode-map (kbd "M-o") 'ff-find-other-file)
        (define-key c++-mode-map (kbd "M-o") 'ff-find-other-file)

#+END_SRC

#+RESULTS:
: ff-find-other-file

** misc
#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode 1)

  ;; Treating terms in CamelCase symbols as separate words makes editing
  ;; a little easier for me, so I like to use subword-mode everywhere.
  (global-subword-mode 1)

  ;; Compilation output goes to the *compilation* buffer. I rarely have
  ;; that window selected, so the compilation output disappears past the
  ;; bottom of the window. This automatically scrolls the compilation
  ;; window so I can always see the output.
  (setq compilation-scroll-output t)
#+END_SRC
* Programming
** c++
*** ggtags
#+BEGIN_SRC emacs-lisp
  (use-package ggtags
  :ensure t
  :config 
  (add-hook 'c-mode-common-hook
            (lambda ()
              (when (derived-mode-p 'c-mode 'c++-mode)
                (ggtags-mode 1))))
  )
#+END_SRC
*** indentation
#+BEGIN_SRC
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
(c-set-offset 'substatement-open 0)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC
(defun my-c-mode-common-hook ()
 ;; my customizations for all of c-mode, c++-mode
(c-set-offset 'substatement-open 0)


 setq-default c-indent-tabs-mode t     ; Pressing TAB should cause indentation
                c-indent-level 4         ; A TAB is equivilent to four spaces
                c-argdecl-indent 0       ; Do not indent argument decl's extra
                c-tab-always-indent t
                backward-delete-function nil) ; DO NOT expand tabs when deleting
  (c-add-style "my-c-style" '((c-continued-statement-offset 4))) ; If a statement continues on the next line, indent the continuation by 4

  (defun my-c-mode-hook ()
    (c-set-style "my-c-style")
    (c-set-offset 'substatement-open '0) ; brackets should be at same indentation level as the statements they open
    (c-set-offset 'inline-open '+)
    (c-set-offset 'block-open '+)
    (c-set-offset 'brace-list-open '+)   ; all "opens" should be indented by the c-indent-level
    (c-set-offset 'case-label '+))       ; indent case labels by c-indent-level, too
  (add-hook 'c-mode-hook 'my-c-mode-hook)
  (add-hook 'c++-mode-hook 'my-c-mode-hook)

#+END_SRC

#+RESULTS:
| my-c-mode-hook | irony-mode | er/add-cc-mode-expansions | (lambda nil (sb-rtags--menu-adds C++)) | (lambda nil (easy-menu-add-item nil (quote (C++)) (rtags-submenu-list))) |

*** keybindings
#+BEGIN_SRC emacs-lisp 
  ;; c++ mode debugging
  (global-set-key (kbd "<f6>") 'gdb)

  (global-set-key (kbd "<f7>")'compile)
  (global-set-key (kbd "<f9>") 'gud-break)

  (global-set-key (kbd "<f10>") 'gud-next)
  (global-set-key (kbd "<f11>") 'gud-step)
#+END_SRC

#+RESULTS:
: gud-step

** Web Mode
#+BEGIN_SRC emacs-lisp
    (use-package web-mode
      :ensure t
      :config
	   (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
	   (add-to-list 'auto-mode-alist '("\\.vue?\\'" . web-mode))
	   (setq web-mode-engines-alist
		 '(("django"    . "\\.html\\'")))
	   (setq web-mode-ac-sources-alist
	   '(("css" . (ac-source-css-property))
	   ("vue" . (ac-source-words-in-buffer ac-source-abbrev))
           ("html" . (ac-source-words-in-buffer ac-source-abbrev))))
  (setq web-mode-enable-auto-closing t))
  (setq web-mode-enable-auto-quoting t) ; this fixes the quote problem I mentioned
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2)

#+END_SRC
* Shell
** Better Shell
#+BEGIN_SRC emacs-lisp :tangle no
(use-package better-shell
    :ensure t
    :bind (("C-'" . better-shell-shell)
           ("C-;" . better-shell-remote-open)))
#+END_SRC
** eshell stuff
#+BEGIN_SRC emacs-lisp

  (use-package shell-switcher
    :ensure t
    :config 
    (setq shell-switcher-mode t)
    :bind (("C-'" . shell-switcher-switch-buffer)
	   ("C-x 4 '" . shell-switcher-switch-buffer-other-window)
	   ("C-M-'" . shell-switcher-new-shell)))

#+END_SRC
#+RESULTS:
: t
* Elfeed
#+BEGIN_SRC emacs-lisp
(setq elfeed-db-directory "~/Dropbox/shared/elfeeddb")

;; use an org file to organise feeds
(use-package elfeed-org
  :ensure t
  :config
  (elfeed-org)
  (setq rmh-elfeed-org-files (list "~/Dropbox/shared/elfeed.org")))

(defun elfeed-mark-all-as-read ()
      (interactive)
      (mark-whole-buffer)
      (elfeed-search-untag-all-unread))

;;functions to support syncing .elfeed between machines
;;makes sure elfeed reads index from disk before launching
(defun bjm/elfeed-load-db-and-open ()
  "Wrapper to load the elfeed db from disk before opening"
  (interactive)
  (elfeed-db-load)
  (elfeed)
  (elfeed-search-update--force))

;;write to disk when quiting
(defun bjm/elfeed-save-db-and-bury ()
  "Wrapper to save the elfeed db to disk before burying buffer"
  (interactive)
  (elfeed-db-save)
  (quit-window))

(defalias 'elfeed-toggle-star
  (elfeed-expose #'elfeed-search-toggle-all 'star))

(use-package elfeed
  :ensure t
  :bind (:map elfeed-search-mode-map
	      ("q" . bjm/elfeed-save-db-and-bury)
	      ("Q" . bjm/elfeed-save-db-and-bury)
	      ("m" . elfeed-toggle-star)
	      ("M" . elfeed-toggle-star)
              ("j" . vmj/hydra-elfeed/body)
	      ("J" . vmj/hydra-elfeed/body)
	      ))

(use-package elfeed-goodies
  :ensure t
  :config
  (elfeed-goodies/setup))

(defhydra vmj/hydra-elfeed ()
   "filter"
   ("c" (elfeed-search-set-filter "@6-months-ago +cs") "cs")
   ("e" (elfeed-search-set-filter "@6-months-ago +emacs") "emacs")
   ("o" (elfeed-search-set-filter "@6-months-ago +mitocw") "mitocw")
   ("*" (elfeed-search-set-filter "@6-months-ago +star") "Starred")
   ("M" elfeed-toggle-star "Mark")
   ("A" (elfeed-search-set-filter "@6-months-ago") "All")
   ("T" (elfeed-search-set-filter "@1-day-ago") "Today")
   ("Q" bjm/elfeed-save-db-and-bury "Quit Elfeed" :color blue)
   ("q" nil "quit" :color blue)
   )

#+END_SRC
* Transpose lines
#+BEGIN_SRC emacs-lisp

(defun move-line (n)
  "Move the current line up or down by N lines."
  (interactive "p")
  (setq col (current-column))
  (beginning-of-line) (setq start (point))
  (end-of-line) (forward-char) (setq end (point))
  (let ((line-text (delete-and-extract-region start end)))
    (forward-line n)
    (insert line-text)
    ;; restore point to original column in moved line
    (forward-line -1)
    (forward-char col)))

(defun move-line-up (n)
  "Move the current line up by N lines."
  (interactive "p")
  (move-line (if (null n) -1 (- n))))

(defun move-line-down (n)
  "Move the current line down by N lines."
  (interactive "p")
  (move-line (if (null n) 1 n)))

(global-set-key (kbd "C-M-<up>") 'move-line-up)
(global-set-key (kbd "C-M-<down>") 'move-line-down)
#+END_SRC

* Key bindings 
#+BEGIN_SRC emacs-lisp
   ;;Keyboard mappings
  (global-set-key (kbd "\e\ei") (lambda () (interactive) (find-file "~/Dropbox/orgfiles/i.org")))
  (global-set-key (kbd "\e\el") (lambda () (interactive) (find-file "~/Dropbox/orgfiles/links.org")))
  (global-set-key (kbd "\e\ew") (lambda () (interactive) (find-file "~/Dropbox/orgfiles/word.org")))
  (global-set-key (kbd "\e\ec") (lambda () (interactive) (find-file "~/.emacs.d/myinit.org")))
  (global-set-key (kbd "\e\eb") (lambda () (interactive) (find-file "~/Dropbox/orgfiles/books.org")))


  (global-set-key (kbd "<f4>") 'kmacro-end-and-call-macro)
  (global-set-key (kbd "<f5>") 'revert-buffer)
  (global-set-key (kbd "C-\\") "\C-a\C- \C-e\M-w") ;copy current line
  (global-set-key (kbd "<C-f7>") 'toggle-truncate-lines)
  (global-set-key (kbd "C-`") 'other-window)
  (global-set-key (kbd "<C-iso-lefttab>") 'other-window)
  (global-set-key (kbd "C-<return>") 'jump-to-next-newline)
  (global-set-key (kbd "C-x o") 'swap-window)
  (global-set-key (kbd "<C-f6>") 'mlint-clear-warnings)

  (global-set-key (kbd "C-<") 'beginning-of-buffer)
  (global-set-key (kbd "C->") 'end-of-buffer)

  (global-set-key (kbd "<f8>") 'view-mode)

  (global-set-key (kbd "C-;") 'iedit-mode)



#+END_SRC
* edit server & emacs chrome
#+BEGIN_SRC emacs-lisp
(use-package edit-server
	:ensure t 
	:config
        (when (locate-library "edit-server")
        (setq edit-server-new-frame nil)
        (edit-server-start)))
#+END_SRC
* Engine mode 
Enable [[https://github.com/vmj/engine-mode][engine-mode]] and define a few useful engines.

#+BEGIN_SRC emacs-lisp
  (require 'engine-mode)

  (defengine duckduckgo
    "https://duckduckgo.com/?q=%s"
    :keybinding "d")

  (defengine github
    "https://github.com/search?ref=simplesearch&q=%s"
    :keybinding "g")

  (defengine google
    "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
    :keybinding "l")

  (defengine rfcs
    "http://pretty-rfc.herokuapp.com/search?q=%s")

  (defengine stack-overflow
    "https://stackoverflow.com/search?q=%s"
    :keybinding "s")

  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w")

  (defengine wiktionary
    "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

  (defengine youtube
    "https://www.youtube.com/results?search_query=%s"
    :keybinding "y")

  (engine-mode t)

#+END_SRC

#+RESULTS:
: t

* ediff
#+BEGIN_SRC emacs-lisp
  (setq ediff-split-window-function 'split-window-vertically)
  
#+END_SRC

#+RESULTS:
: split-window-vertically

* Writing prose
** Look up definitions in Webster 1913

I look up definitions by hitting =C-x w=, which shells out to =sdcv=. I've
loaded that with the (beautifully lyrical) 1913 edition of Webster's dictionary,
so these definitions are a lot of fun.

#+BEGIN_SRC emacs-lisp
  (defun vmj/region-or-word ()
    (if mark-active
        (buffer-substring-no-properties (region-beginning)
                                        (region-end))
      (thing-at-point 'word)))


  (defun vmj/dictionary-prompt ()
    (read-string
     (format "Word (%s): " (or (vmj/region-or-word) ""))
     nil
     nil
     (vmj/region-or-word)))

  (defun vmj/dictionary-define-word ()
    (interactive)
    (let* ((word (vmj/dictionary-prompt))
           (buffer-name (concat "Definition: " word)))
      (with-output-to-temp-buffer buffer-name
        (shell-command (format "sdcv -n %s" word) buffer-name))))

  (define-key global-map (kbd "C-x l") 'vmj/dictionary-define-word)
#+END_SRC

#+RESULTS:
: vmj/dictionary-define-word

** Look up words in a thesaurus

Synosaurus is hooked up to wordnet to provide access to a thesaurus. Hitting
=C-c s= summons it.

#+BEGIN_SRC emacs-lisp

  (use-package synosaurus
  :ensure t)

    (setq-default synosaurus-backend 'synosaurus-backend-wordnet)
    (setq-default synosaurus-choose-method 'popup)
    (add-hook 'after-init-hook #'synosaurus-mode)
    (global-set-key (kbd "C-c l") 'synosaurus-lookup)
    (global-set-key (kbd "C-c r") 'synosaurus-choose-and-replace)


  (use-package mw-thesaurus
  :ensure t
  :config
  (setq mw-thesaurus--api-key "353fc03f-5f64-4d61-84a5-0e630f1c96ea"))


#+END_SRC

#+RESULTS:
: synosaurus-choose-and-replace

** Editing with Markdown

Because I can't always use =org=.

- Associate =.md= files with GitHub-flavored Markdown.
- I'd like spell-checking running when editing Markdown.
- Use =pandoc= to render the results.
- Leave the code block font unchanged.

#+BEGIN_SRC emacs-lisp
;;  (use-package markdown-mode
;;    :commands gfm-mode

;;    :mode (("\\.md$" . gfm-mode))

;;    :config
;;    (setq markdown-command "pandoc --standalone --mathjax --from=markdown")
;;    (add-hook 'gfm-mode-hook 'flyspell-mode)
;;    (custom-set-faces
;;     '(markdown-code-face ((t nil)))))
#+END_SRC

** Wrap paragraphs automatically

=AutoFillMode= automatically wraps paragraphs, kinda like hitting =M-q=. I wrap
a lot of paragraphs, so this automatically wraps 'em when I'm writing text,
Markdown, or Org.

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'gfm-mode-hook 'turn-on-auto-fill)
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
#+END_SRC

** Cycle between spacing alternatives

Successive calls to =cycle-spacing= rotate between changing the whitespace
around point to:

- A single space,
- No spaces, or
- The original spacing.

Binding this to =M-SPC= it strictly better than the original binding of
=just-one-space=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-SPC") 'cycle-spacing)
#+END_SRC

** Linting prose

I use [[http://proselint.com/][proselint]] to check my prose for common errors. This creates a flycheck
checker that runs proselint in texty buffers and displays my errors.

#+BEGIN_SRC emacs-lisp
  (require 'flycheck)

  (flycheck-define-checker proselint
    "A linter for prose."
    :command ("proselint" source-inplace)
    :error-patterns
    ((warning line-start (file-name) ":" line ":" column ": "
              (id (one-or-more (not (any " "))))
              (message (one-or-more not-newline)
                       (zero-or-more "\n" (any " ") (one-or-more not-newline)))
              line-end))
    :modes (text-mode markdown-mode gfm-mode org-mode))

  (add-to-list 'flycheck-checkers 'proselint)
#+END_SRC

Use flycheck in the appropriate buffers:

#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook #'flycheck-mode)
  (add-hook 'gfm-mode-hook #'flycheck-mode)
  (add-hook 'text-mode-hook #'flycheck-mode)
  (add-hook 'org-mode-hook #'flycheck-mode)
#+END_SRC

** Enable region case modification

#+BEGIN_SRC emacs-lisp
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+END_SRC
