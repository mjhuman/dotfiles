#+STARTUP: overview
#+TITLE: Emacs Configuration
#+AUTHOR: Vinodh MJ Human
#+EMAIL: 
#+OPTIONS: toc:nil num:nil

* Pre-requisites
I've stolen many a configuration from Mike Zamansky and Harry R Schwartz
#+BEGIN_SRC emacs-lisp

  ;; INSTALL PACKAGES
  ;; --------------------------------------

  ;; Bootstrap `use-package'
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))


  (setq use-package-verbose t)
  (setq use-package-always-ensure t)

  (set-default-coding-systems 'utf-8)
  (prefer-coding-system 'utf-8)


  ;;Install paradox package manager
;  (use-package paradox
 ;   :ensure t)

  ;; set browser to firefox
  (setq browse-url-browser-function 'browse-url-firefox)

#+END_SRC

#+RESULTS:
: browse-url-firefox

* vmj custom
Most of these things are stolen from HRS
** General
#+BEGIN_SRC emacs-lisp
  (defun vmj/view-buffer-name ()
    "Display the filename of the current buffer."
    (interactive)
    (message (buffer-file-name)))


(defun vmj/copy-buffer-path ()
    "Copy current file path"
    (interactive)
    (let (fpln)
      (setq fpln buffer-file-name)
      (kill-new fpln)
      (message (buffer-file-name))))

(defun vmj/copy-buffer-name ()
    "Copy current file name"
    (interactive)
  (insert (buffer-name (window-buffer (minibuffer-selected-window)))))

  (defun vmj/generate-scratch-buffer ()
    "Create and switch to a temporary scratch buffer with a random
         name."
    (interactive)
    (switch-to-buffer (make-temp-name "scratch-")))

  (defun vmj/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (defun vmj/copy-file-line-matlab ()
    "Copy current file path and line number to clipboard and trim till matlabroot"
    (interactive)
    (let (fpln)
      (setq fpln (concatenate 'string (buffer-file-name) ":" (number-to-string (line-number-at-pos))))
      (setq fpln (split-string fpln "/matlab/"))
      (setq fpln (car (last fpln)))
      (kill-new fpln)
      (message (concat fpln " copied to clipboard"))))

#+END_SRC
** Frame title
The default frame title isn't useful. This binds it to the name of the current
project:

#+BEGIN_SRC emacs-lisp
                                          ;  (setq frame-title-format '((:eval (projectile-project-name))))
#+END_SRC

** Use fancy lambdas

Why not?

#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode t)
#+END_SRC

** Hide certain modes from the modeline

I'd rather have only a few necessary mode identifiers on my modeline. This
either hides or "renames" a variety of major or minor modes using the =diminish=
package.

#+BEGIN_SRC 
  (defmacro diminish-minor-mode (filename mode &optional abbrev)
    `(eval-after-load (symbol-name ,filename)
       '(diminish ,mode ,abbrev)))

  (defmacro diminish-major-mode (mode-hook abbrev)
    `(add-hook ,mode-hook
               (lambda () (setq mode-name ,abbrev))))

  (diminish-minor-mode 'abbrev 'abbrev-mode)
  (diminish-minor-mode 'simple 'auto-fill-function)
  (diminish-minor-mode 'company 'company-mode)
  (diminish-minor-mode 'eldoc 'eldoc-mode)
  (diminish-minor-mode 'flycheck 'flycheck-mode)
  (diminish-minor-mode 'flyspell 'flyspell-mode)
  (diminish-minor-mode 'global-whitespace 'global-whitespace-mode)
  (diminish-minor-mode 'projectile 'projectile-mode)
  (diminish-minor-mode 'ruby-end 'ruby-end-mode)
  (diminish-minor-mode 'subword 'subword-mode)
  (diminish-minor-mode 'undo-tree 'undo-tree-mode)
  (diminish-minor-mode 'yard-mode 'yard-mode)
  (diminish-minor-mode 'yasnippet 'yas-minor-mode)
  (diminish-minor-mode 'wrap-region 'wrap-region-mode)

  (diminish-minor-mode 'paredit 'paredit-mode " ?")

  (diminish-major-mode 'emacs-lisp-mode-hook "el")
  (diminish-major-mode 'haskell-mode-hook "?=")
  (diminish-major-mode 'lisp-interaction-mode-hook "?")
  (diminish-major-mode 'python-mode-hook "Py")
#+END_SRC
* Interface tweaks
** Start up
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
  (tool-bar-mode -1)
  (fset 'yes-or-no-p 'y-or-n-p)
  (global-linum-mode t) ;; enable line numbers globally
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
  (setq ivy-use-virtual-buffers t)
  (defun jump-to-next-newline()
    "Move to the end of the line and return"
    (interactive)
    (move-end-of-line)
    (newline))
  (setq ivy-format-function 'ivy-format-function-line)
  (setq ivy-display-style 'fancy)
  ;;(setq view-read-only t)



#+END_SRC

#+RESULTS:
: 0

** Ace windows for easy window switching
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :init
    (progn
      (setq aw-scope 'frame)
      (global-set-key (kbd "C-x O") 'other-frame)
      (global-set-key [remap other-window] 'ace-window)
      (custom-set-faces
       '(aw-leading-char-face
         ((t (:inherit ace-jump-face-foreground :height 3.0))))) 
      ))

  (defun swap-window()
    "Swap windows and leave focus on the original window"
    (interactive)
    (ace-swap-window)
    (aw-flip-window))

#+END_SRC

#+RESULTS:

** Themes and modeline:
#+BEGIN_SRC emacs-lisp
  (use-package moe-theme
    :ensure t)

  (use-package powerline
    :ensure t
    :config
                                          ;(powerline-moe-theme)
    (setq moe-theme-highlight-buffer-id t)
    )
  (set-frame-font "DejaVu Sans Mono 13" nil t)
  (add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono 13"))

;;(set-frame-font "Inconsolata Medium 14" nil t)
;;(add-to-list 'default-frame-alist '(font . "Inconsolata Medium 14"))

#+END_SRC

#+RESULTS:
: ((font . DejaVu Sans Mono 13) (font . DejaVu Sans Mono 11) (fullscreen . maximized))
** Custom solarized-dark theme

I like the solarized-dark theme. I prefer keeping all the characters in the same
side and font, though.

#+BEGIN_SRC emacs-lisp
(use-package solarized-theme
:ensure t)
  (defun vmj/apply-solarized-theme ()
    (setq solarized-use-variable-pitch nil)
    (setq solarized-height-plus-1 1.0)
    (setq solarized-height-plus-2 1.0)
    (setq solarized-height-plus-3 1.0)
    (setq solarized-height-plus-4 1.0)
    (setq solarized-high-contrast-mode-line t)
    (load-theme 'solarized-dark t))
#+END_SRC

If this code is being evaluated by =emacs --daemon=, ensure that each subsequent
frame is themed appropriately.

#+BEGIN_SRC emacs-lisp
  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame)
                  (vmj/apply-solarized-theme)))
    (vmj/apply-solarized-theme))
#+END_SRC
** Windows
#+BEGIN_SRC emacs-lisp

(defun window-split-toggle ()
  "Toggle between horizontal and vertical split with two windows."
  (interactive)
  (if (> (length (window-list)) 2)
      (error "Can't toggle with more than 2 windows!")
    (let ((func (if (window-full-height-p)
                    #'split-window-vertically
                  #'split-window-horizontally)))
      (delete-other-windows)
      (funcall func)
      (save-selected-window
        (other-window 1)
        (switch-to-buffer (other-buffer))))))

(window-split-toggle)
#+END_SRC
* Org mode
** org bullets
Org bullets makes things look pretty

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

  ;;I like seeing a little downward-pointing arrow instead of the usual ellipsis (...) that org displays when there?s stuff under a header.
  (setq org-ellipsis "?")

  ;; Use syntax highlighting in source blocks while editing.
  (setq org-src-fontify-natively t)

  ;; Make TAB act as if it were issued in a buffer of the language?s major mode.
  (setq org-src-tab-acts-natively t)

  ;; When editing a code snippet, use the current window rather than popping open a new one (which shows the same information).
  (setq org-src-window-setup 'current-window)

  ;; Quickly insert a block of elisp:
  (add-to-list 'org-structure-template-alist
               '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))

  ;; Enable spell-checking in Org-mode.
  (add-hook 'org-mode-hook 'flyspell-mode)

#+END_SRC
** org custom variables
#+BEGIN_SRC emacs-lisp
  (custom-set-variables
   '(org-directory "~/Dropbox/orgfiles")
   '(org-default-notes-file (concat org-directory "/notes.org"))
   '(org-export-html-postamble nil)
   '(org-hide-leading-stars t)
   '(org-startup-folded (quote overview))
   '(org-startup-indented t)
   )

  (setq org-file-apps
        (append '(
                  ("\\.pdf\\'" . "evince %s")
                  ) org-file-apps ))

#+END_SRC
** org agenda
#+BEGIN_SRC emacs-lisp

  ;;scheduling 
  (global-set-key "\C-ca" 'org-agenda)

  (setq org-agenda-custom-commands
        '(("c" "Simple agenda view"
           ((agenda "")
            (alltodo "")))))

  (setq org-agenda-files (list "~/Dropbox/orgfiles/i.org"
                               "~/Dropbox/orgfiles/arts.org"
                               "~/Dropbox/orgfiles/books.org"
                               "~/Dropbox/orgfiles/eee.org"
                               "~/Dropbox/orgfiles/gcal.org"
                               "~/Dropbox/orgfiles/inbox.org"
                               "~/Dropbox/orgfiles/movies.org"))

#+END_SRC

** org ac
#+BEGIN_SRC emacs-lisp

  (use-package org-ac
    :ensure t
    :init (progn
            (require 'org-ac)
            (org-ac/config-default)
            ))

  (add-to-list 'ac-modes 'org-mode)

#+END_SRC
** org journal
#+BEGIN_SRC emacs-lisp
    (use-package org-journal
      :ensure t
      :defer t
      :custom
      (org-journal-dir "~/Dropbox/orgfiles/journal/")
      (org-journal-date-format "%A, %d %B %Y")
      (org-journal-file-type `yearly)
      (org-journal-encrypt-journal t)
      (org-journal-enable-agenda-integration t))

  (defun org-journal-find-location ()
    ;; Open today's journal, but specify a non-nil prefix argument in order to
    ;; inhibit inserting the heading; org-capture will insert the heading.
    (org-journal-new-entry t)
    ;; Position point on the journal's top-level heading so that org-capture
    ;; will add the new entry as a child entry.
    (goto-char (point-min)))
#+END_SRC

#+RESULTS:
: org-journal-find-location
** org capture
#+BEGIN_SRC emacs-lisp

  (global-set-key (kbd "C-c c") 'org-capture)

  (setq org-capture-templates
        '(("a" "Appointment" entry (file  "~/Dropbox/orgfiles/gcal.org" )
           "* %?\n\n%^T\n\n:PROPERTIES:\n\n:END:\n\n")
          ("l" "Link" entry (file+headline "~/Dropbox/orgfiles/links.org" "Links")
           "* %? %^L" :prepend t)
          ("b" "Blog idea" entry (file+headline "~/Dropbox/orgfiles/arts.org" "Blog Topics:")
           "* %?\n" :prepend t)
          ("y" "Youtube idea" entry (file+headline "~/Dropbox/orgfiles/arts.org" "Youtube Topics:")
           "* %?\n" :prepend t)
          ("t" "To Do Item" entry (file+headline "~/Dropbox/orgfiles/i.org" "To Do")
           "* TODO %? \n%u" :prepend t)
          ("d" "Detailed To Do Item" entry (file+headline "~/Dropbox/orgfiles/i.org" "To Do")
           "* TODO %^C %? %^g\n%u" :prepend t)
          ("n" "Note" entry (file+headline "~/Dropbox/orgfiles/notes.org" "Notes")
           "* %?\n%u" :prepend t)
          ("w" "Word" entry (file+headline "~/Dropbox/orgfiles/books.org" "Words")
           "* %?\n" :prepend t)
          ("p" "Phrase" entry (file+headline "~/Dropbox/orgfiles/Words.org" "Phrases")
           "* %?\n" :prepend t)
          ("j" "Journal entry" entry (function org-journal-find-location)
           "* %(format-time-string org-journal-time-format)%^{Title}\n%i%?")
        ))
#+END_SRC

#+RESULTS:
| a | Appointment | entry | (file ~/Dropbox/orgfiles/gcal.org) | * %? |
** org mobile   
#+BEGIN_SRC emacs-lisp        
  ;; Set to the name of the file where new notes will be stored
  (setq org-mobile-inbox-for-pull "~/Dropbox/orgfiles/mobile.org")
  ;; Set to <your Dropbox root directory>/MobileOrg.
  (setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
  ;;(run-with-idle-timer 360 1 'org-mobile-pull)
  ;;(run-with-idle-timer 300 1 'org-mobile-push)
#+END_SRC
** org refile
#+BEGIN_SRC emacs-lisp

  (setq org-refile-targets '((org-agenda-files :maxlevel . 1)))
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

** org other stuff
#+BEGIN_SRC emacs-lisp

  ;(require 'org-mu4e)

    (defadvice org-capture-finalize 
        (after delete-capture-frame activate)  
      "Advise capture-finalize to close the frame"  
      (if (equal "capture" (frame-parameter nil 'name))  
          (delete-frame)))

    (defadvice org-capture-destroy 
        (after delete-capture-frame activate)  
      "Advise capture-destroy to close the frame"  
      (if (equal "capture" (frame-parameter nil 'name))  
          (delete-frame)))  

    (use-package noflet
      :ensure t )
    (defun make-capture-frame ()
      "Create a new frame and run org-capture."
      (interactive)
      (make-frame '((name . "capture")))
      (select-frame-by-name "capture")
      (delete-other-windows)
      (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
        (org-capture)))

  (with-eval-after-load 'org
    (require 'ox-md)
    (require 'ox-beamer))

    ;; Don?t ask before evaluating code blocks.
    (setq org-confirm-babel-evaluate nil)

                                            ;(use-package epresent
                                            ;:ensure t)

#+END_SRC

#+RESULTS:
** org align, justify
#+BEGIN_SRC emacs-lisp

  (add-hook 'org-mode-hook '(lambda () (setq fill-column 80)))
  (add-hook 'org-mode-hook 'turn-on-auto-fill)

  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'text-mode-hook '(lambda() (set-fill-column 80)))
#+END_SRC
** org colors
#+BEGIN_SRC emacs-lisp
  (set-face-foreground 'org-link "MistyRose4")
#+END_SRC
** org pandoc
#+BEGIN_SRC emacs-lisp
(use-package ox-pandoc
:ensure t
:config
;; default options for all output formats
(setq org-pandoc-options '((standalone . t)))
;; cancel above settings only for 'docx' format
(setq org-pandoc-options-for-docx '((standalone . nil)))
;; special settings for beamer-pdf and latex-pdf exporters
(setq org-pandoc-options-for-beamer-pdf '((pdf-engine . "xelatex")))
(setq org-pandoc-options-for-latex-pdf '((pdf-engine . "pdflatex")))
;; special extensions for markdown_github output
(setq org-pandoc-format-extensions '(markdown_github+pipe_tables+raw_html)))

#+END_SRC
** org capture screen
#+BEGIN_SRC emacs-lisp
(defadvice org-capture-finalize
(after delete-capture-frame activate)
"Advise capture-finalize to close the frame"
(if (equal "capture" (frame-parameter nil 'name))
(delete-frame)))

(defadvice org-capture-destroy
(after delete-capture-frame activate)
"Advise capture-destroy to close the frame"
(if (equal "capture" (frame-parameter nil 'name))
(delete-frame)))

(use-package noflet
:ensure t )
(defun make-capture-frame ()
"Create a new frame and run org-capture."
(interactive)
(make-frame '((name . "capture")))
(select-frame-by-name "capture")
(delete-other-windows)
(noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
  (org-capture)))

#+END_SRC

** org confluence
#+BEGIN_SRC
  (add-to-list 'load-path "~/.emacs.d/lisp/")
  (load "ox-confluence.el")

#+END_SRC


#+RESULTS:
: t
* smex
#+BEGIN_SRC emacs-lisp

  (use-package smex
    :ensure t
    :config 
    (global-set-key (kbd "M-x") 'smex)
    (global-set-key (kbd "M-X") 'smex-major-mode-commands)
    ;; This is your old M-x.
    (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command))
#+END_SRC

#+RESULTS:
: t
* abo-abo
** Swiper / Ivy / Counsel
Swiper gives us a really efficient incremental search with regular expressions
and Ivy / Counsel replace a lot of ido or helms completion functionality
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t
    :bind
    (("M-y" . counsel-yank-pop)
     :map ivy-minibuffer-map
     ("M-y" . ivy-next-line)))

  (use-package ivy
    :ensure t
    :diminish (ivy-mode)
    :bind (("C-x b" . ivy-switch-buffer))
    :config
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-display-style 'fancy)
    (setq ivy-height 20)
    (setq ivy-format-function 'ivy-format-function-line))

  (use-package swiper
    :ensure t
    :bind (("C-s" . swiper)
           ("C-r" . swiper)
           ("C-c C-r" . ivy-resume)
           ("M-x" . counsel-M-x)
           ("C-x r b" . counsel-bookmark)
           ("C-x C-f" . counsel-find-file))
    :config
    (progn
      (ivy-mode 1)
      (setq ivy-use-virtual-buffers t)
      (setq ivy-display-style 'fancy)
      (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
      ))

  (defface ivy-current-match
    '((((class color) (background light))
       :background "#1a4b77" :foreground "white")
      (((class color) (background dark))
       :background "#65a7e2" :foreground "black"))
    "Face used by Ivy for highlighting first match.")

(setq counsel-find-file-ignore-regexp
        (concat
         ;; File names beginning with # or .
         "\\(?:\\`[#.]\\)"
         ;; File names ending with # or ~
         "\\|\\(?:\\`.+?[#~]\\'\\)")) 

#+END_SRC

#+RESULTS:
: ivy-current-match

** Avy
navigate by searching for a letter on the screen and jumping to it
See https://github.com/abo-abo/avy for more info
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind ("M-s" . avy-goto-word-1)) ;; changed from char as per jcs
#+END_SRC
** Hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra 
    :ensure hydra
    :init 
    (global-set-key
     (kbd "C-x t")
     (defhydra toggle (:color blue)
       "toggle"
       ("a" abbrev-mode "abbrev")
       ("s" flyspell-mode "flyspell")
       ("d" toggle-debug-on-error "debug")
       ("c" fci-mode "fCi")
       ("f" auto-fill-mode "fill")
       ("t" toggle-truncate-lines "truncate")
       ("w" whitespace-mode "whitespace")
       ("c" flycheck-mode "flycheck")
       ("o" dired-omit-mode "dired omit mode")
       ("h" window-split-toggle "window split toggle")
       ("q" nil "cancel")))
    (global-set-key
     (kbd "C-x j")
     (defhydra gotoline 
       ( :pre (linum-mode 1)
              :post (linum-mode -1))
       "goto"
       ("t" (lambda () (interactive)(move-to-window-line-top-bottom 0)) "top")
       ("b" (lambda () (interactive)(move-to-window-line-top-bottom -1)) "bottom")
       ("m" (lambda () (interactive)(move-to-window-line-top-bottom)) "middle")
       ("e" (lambda () (interactive)(end-of-buffer)) "end")
       ("c" recenter-top-bottom "recenter")
       ("n" next-line "down")
       ("p" (lambda () (interactive) (forward-line -1))  "up")
       ("g" goto-line "goto-line")
       )))
    ;;     (global-set-key
    ;;          (kbd "C-c t")
    ;;          (defhydra hydra-global-org (:color blue)
    ;;            "Org"
    ;;            ("t" org-timer-start "Start Timer")
    ;;            ("s" org-timer-stop "Stop Timer")
    ;;            ("r" org-timer-set-timer "Set Timer") ; This one requires you be in an orgmode doc, as it sets the timer for the header
    ;;            ("p" org-timer "Print Timer") ; output timer value to buffer
    ;;            ("w" (org-clock-in '(4)) "Clock-In") ; used with (org-clock-persistence-insinuate) (setq org-clock-persist t)
    ;;            ("o" org-clock-out "Clock-Out") ; you might also want (setq org-log-note-clock-out t)
    ;;            ("j" org-clock-goto "Clock Goto") ; global visit the clocked task
    ;;            ("c" org-capture "Capture") ; Don't forget to define the captures you want http://orgmode.org/manual/Capture.html
    ;;            ("l" (or )rg-capture-goto-last-stored "Last Capture")))
    

  (global-set-key
   (kbd "C-x f")
   (defhydra frequent (:color blue)
     "frequent"
     ("f" counsel-find-file "find-file")
     ("l" mlint-clear-warnings "mlint clear")
     ("b" counsel-bookmark "bookmarks")
     ("a" mark-whole-buffer "select all")
     ("r" revert-buffer "refresh")
     ("p" crepro "projectile")
     ("s" (find-file "/local-ssd/vjayakri") "ssd")
     ("n" (find-file "/mathworks/devel/sandbox/vjayakri") "sbs")
     ("w" auto-fill-mode "auto wrap")
     ("g" (find-file "~/projects/cpp/graph") "graph")
     ("v" peep-dired "peep view")
     ("2" (find-file "/ssd2") "ssd2")
     ("c" vmj/copy-file-line-matlab "copy file line to clipboard")
     ("i" yas/insert-snippet "insert snippet")
     ("t" (counsel-find-file "~/temper") "temper")
     ("h" (counsel-find-file "~/") "home")))

#+END_SRC

#+RESULTS:
: frequent/body
** Additional configuration
#+BEGIN_SRC
(setq counsel-find-file-ignore-regexp
        (concat
         ;; File names beginning with # or .
;;         "\\(?:\\`[#.]\\)"
         ;; File names ending with # or ~
         "\\|\\(?:\\`.+?[#~]\\'\\)"))
#+END_SRC

#+RESULTS:
: \|\(?:\`.+?[#~]\'\)

* Necessary
** Misc packages
#+BEGIN_SRC emacs-lisp

                                          ; Highlights the current cursor line
  (when window-system
    (global-hl-line-mode))

                                          ; flashes the cursor's line when you scroll
  (use-package beacon
    :ensure t
    :config
    (beacon-mode 1)
                                          ; (setq beacon-color "#666600")
    )

                                          ; deletes all the whitespace when you hit backspace or delete
  (use-package hungry-delete
    :ensure t
    :config
    (global-hungry-delete-mode))

                                          ; expand the marked region in semantic increments (negative prefix to reduce region)
  (use-package expand-region
    :ensure t
    :config 
    (global-set-key (kbd "C-=") 'er/expand-region))

  (setq save-interprogram-paste-before-kill t)

                                          ; font scaling
  (use-package default-text-scale
    :ensure t
    :config
    (global-set-key (kbd "C-M-=") 'default-text-scale-increase)
    (global-set-key (kbd "C-M--") 'default-text-scale-decrease))

                                          ;origami folding
  (use-package origami
    :ensure t)

  (use-package which-key
    :ensure t 
    :config
    (which-key-mode))

#+END_SRC
** Autocomplete
#+BEGIN_SRC  emacs-lisp
  (use-package auto-complete
    :ensure t
    :init
    (progn
      (ac-config-default)
      (global-auto-complete-mode t)
      (add-to-list 'ac-modes 'matlab-mode)
      (add-to-list 'ac-modes 'nxml-mode)
      ))
#+END_SRC
  
** Flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :init
    (global-flycheck-mode t))

  (add-hook 'c++-mode-hook (lambda () (setq flycheck-gcc-language-standard "c++11")))
  (add-hook 'c++-mode-hook (lambda () (setq flycheck-clang-language-standard "c++11")))
                                          ;(add-hook 'text-mode-hook 'flyspell-mode)
                                          ;(add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+END_SRC

#+RESULTS:
| (lambda nil (setq flycheck-clang-language-standard c++11)) | (lambda nil (setq flycheck-gcc-language-standard c++11)) | irony-mode | er/add-cc-mode-expansions | (lambda nil (sb-rtags--menu-adds C++)) | (lambda nil (easy-menu-add-item nil (quote (C++)) (rtags-submenu-list))) |

** Yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :init
    (yas-global-mode 1))

  (use-package yasnippet-snippets
    :ensure t)

#+END_SRC

#+RESULTS:

** Undo Tree
#+BEGIN_SRC
    (use-package undo-tree
      :ensure t
      :init
      (global-undo-tree-mode))
#+END_SRC
** Reveal.js
#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :ensure ox-reveal)

  (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
  (setq org-reveal-mathjax t)

  (use-package htmlize
    :ensure t)
#+END_SRC

#+RESULTS:
: t

** iedit and narrow / widen dwim

#+BEGIN_SRC emacs-lisp
                                          ; mark and edit all copies of the marked region simultaneously. 
  (use-package iedit
    :ensure t)

                                          ; if you're windened, narrow to the region, if you're narrowed, widen
                                          ; bound to C-x n
  (defun narrow-or-widen-dwim (p)
    "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
  Intelligently means: region, org-src-block, org-subtree, or defun,
  whichever applies first.
  Narrowing to org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer is already
  narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing command.
           ;; Remove this first conditional if you don't want it.
           (cond ((ignore-errors (org-edit-src-code))
                  (delete-other-windows))
                 ((org-at-block-p)
                  (org-narrow-to-block))
                 (t (org-narrow-to-subtree))))
          (t (narrow-to-defun))))

  ;; (define-key endless/toggle-map "n" #'narrow-or-widen-dwim)
  ;; This line actually replaces Emacs' entire narrowing keymap, that's
  ;; how much I like this command. Only copy it if that's what you want.
  (define-key ctl-x-map "n" #'narrow-or-widen-dwim)

#+END_SRC


#+RESULTS:
=narrow-or-widen-dwim
=** Dired
#+BEGIN_SRC emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/lisp/")
    (load "dired+")

    (use-package dired-quick-sort
      :ensure t
      :config
      (dired-quick-sort-setup))

    (use-package peep-dired
      :ensure t
      :defer t ; don't access `dired-mode-map' until `peep-dired' is loaded
      :bind (:map dired-mode-map
                  ("P" . peep-dired))
      :config
      (setq peep-dired-cleanup-on-disable t)
      (setq peep-dired-enable-on-directories t)
      (setq peep-dired-ignored-extensions '("mkv" "iso" "mp4" "slx" "mdl")))


                                            ; copy to the other open dired buffer
    (setq dired-listing-switches "-al --group-directories-first")

    (setq dired-dwim-target t)
    (setq dired-recursive-copies 'always)

  (setq dired-omit-mode t)

    (set-face-foreground 'diredp-dir-name "IndianRed")
    (set-face-foreground 'diredp-file-name "gray")
    (set-face-foreground 'diredp-ignored-file-name "dim gray")
    (set-face-foreground 'diredp-file-suffix "dark cyan")
    (set-face-background 'diredp-dir-name "#002b36")

    (setq dired-dwim-target t)
    (setq dired-recursive-copies 'always)
#+END_SRC

#+RESULTS:
: always

** Ibuffer
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (setq ibuffer-saved-filter-groups
        (quote (("default"
                 ("dired" (mode . dired-mode))
                 ("org" (name . "^.*org$"))
                 ("web" (or (mode . web-mode) (mode . js2-mode)))
                 ("shell" (or (mode . eshell-mode) (mode . shell-mode)))
                 ("programming" (or
                                 (mode . python-mode)
                                 (mode . matlab-mode)
                                 (mode . c++-mode)))

                 ("emacs" (or
                           (name . "^\\*scratch\\*$")
                           (name . "^\\*Messages\\*$")))
                 ))))
  (add-hook 'ibuffer-mode-hook
            (lambda ()
              (ibuffer-switch-to-saved-filter-groups "default")))


#+END_SRC

#+RESULTS:

* Programming essentials
** Babel

#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((python . t)
     (emacs-lisp . t)
     (C . t)
     (js . t)
     (ditaa . t)
     (dot . t)
     (org . t)
     (latex . t )
     ))
#+END_SRC
** Projectile
#+BEGIN_SRC
  ;;  Projectile
  (use-package projectile
    :ensure t
    :config
    (projectile-global-mode)
    (setq projectile-mode-line
          '(:eval (format " Projectile[%s(%s)]"
                          (projectile-project-name))))
    (setq projectile-completion-system 'ivy))

(use-package ag
:ensure t)

(projectile-mode +1)
(define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)

(setq projectile-globally-ignored-files
      (append '(
        "*.*~"
        "*~"
        ".~"
        "*.gz"
        "*.pyc"
        "*.jar"
        "*.tar.gz"
        "*.tgz"
        "*.zip"
        )
          projectile-globally-ignored-files))

(defun my-projectile-test-prefix (project-type)
  "Find default test files suffix based on PROJECT-TYPE."
  (cond
   ((member project-type '(make)) "t")))

(setq projectile-test-prefix 'my-projectile-test-prefix)

;; I don't like projectile automatically creating projects at its wish 
;; I like to add known projects and update them manually
;;(setq projectile-project-root-files-top-down-recurring ".mtf")
;;(setq projectile-project-root-files ".mtf")
;;(setq projectile-project-root-files-bottom-up ".mtf")

#+END_SRC

#+RESULTS:
: projectile-command-map

** Smart Parens
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :config
    (smartparens-global-mode t)
    (show-smartparens-global-mode t)
    :bind
    ( ("C-<down>" . sp-down-sexp)
      ("C-<up>"   . sp-up-sexp)
      ("M-<down>" . sp-backward-down-sexp)
      ("M-<up>"   . sp-backward-up-sexp)
      ("C-M-a" . sp-beginning-of-sexp)
      ("C-M-e" . sp-end-of-sexp)

      ("C-M-f" . sp-forward-sexp)
      ("C-M-b" . sp-backward-sexp)

      ("C-M-n" . sp-next-sexp)
      ("C-M-p" . sp-previous-sexp)

      ("C-S-f" . sp-forward-symbol)
      ("C-S-b" . sp-backward-symbol)

      ("C-<right>" . sp-forward-slurp-sexp)
      ("M-<right>" . sp-forward-barf-sexp)
      ("C-<left>"  . sp-backward-slurp-sexp)
      ("M-<left>"  . sp-backward-barf-sexp)

      ("C-M-t" . sp-transpose-sexp)
      ("C-M-k" . sp-kill-sexp)
      ("C-k"   . sp-kill-hybrid-sexp)
      ("M-k"   . sp-backward-kill-sexp)
      ("C-M-w" . sp-copy-sexp)

      ("C-M-d" . delete-sexp)

      ("M-<backspace>" . backward-kill-word)
      ("C-<backspace>" . sp-backward-kill-word)
      ([remap sp-backward-kill-word] . backward-kill-word)

      ("M-[" . sp-backward-unwrap-sexp)
      ("M-]" . sp-unwrap-sexp)

      ("C-x C-t" . sp-transpose-hybrid-sexp)

      ("C-c ("  . wrap-with-parens)
      ("C-c ["  . wrap-with-brackets)
      ("C-c {"  . wrap-with-braces)
      ("C-c '"  . wrap-with-single-quotes)
      ("C-c \"" . wrap-with-double-quotes)
      ("C-c _"  . wrap-with-underscores)
      ("C-c `"  . wrap-with-back-quotes)
      ))


#+END_SRC

#+RESULTS:
: wrap-with-back-quotes

** Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("C-x g" . magit-status)
    :config
    (setq git-commit-summary-max-length 50)
    (add-hook 'git-commit-mode-hook 'turn-on-flyspell))

#+END_SRC
** LaTeX
#+BEGIN_SRC emacs-lisp

  ;; latex
                                          ;(use-package tex
                                          ;:ensure auctex)

                                          ;(defun tex-view ()
                                          ;    (interactive)
                                          ;    (tex-send-command "evince" (tex-append tex-print-file ".pdf")))
#+END_SRC
** irony
#+BEGIN_SRC
  ;; == irony-mode ==

  (use-package irony
    :ensure t)

(add-hook 'c++-mode-hook 'irony-mode)
(add-hook 'c-mode-hook 'irony-mode)
(add-hook 'objc-mode-hook 'irony-mode)

(add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)

#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC 
(add-hook 'c++-mode-hook 'irony-mode)
(add-hook 'c-mode-hook 'irony-mode)

(defun my-irony-mode-hook ()
  (define-key irony-mode-map
      [remap completion-at-point] 'counsel-irony)
  (define-key irony-mode-map
      [remap complete-symbol] 'counsel-irony))
(add-hook 'irony-mode-hook 'my-irony-mode-hook)
(add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
#+END_SRC

#+RESULTS:
| irony-cdb-autosetup-compile-options | my-irony-mode-hook | company-irony-setup-begin-commands |

#+BEGIN_SRC 
   (use-package irony
            :ensure t
              :defer t
              :init
              (add-hook 'c++-mode-hook 'irony-mode)
              (add-hook 'c-mode-hook 'irony-mode)
              (add-hook 'objc-mode-hook 'irony-mode)
              :config
              ;; replace the `completion-at-point' and `complete-symbol' bindings in
              ;; irony-mode's buffers by irony-mode's function
      (defun my-irony-mode-hook ()
        (define-key irony-mode-map
            [remap completion-at-point] 'counsel-irony)
        (define-key irony-mode-map
            [remap complete-symbol] 'counsel-irony))
      (add-hook 'irony-mode-hook 'my-irony-mode-hook)
      (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;;  == company-mode ==
  (use-package company
    :ensure t
    :defer t
    :init (add-hook 'after-init-hook 'global-company-mode)
    :config
    (use-package company-irony :ensure t :defer t)
    (setq company-idle-delay              nil
          company-minimum-prefix-length   2
          company-show-numbers            t
          company-tooltip-limit           20
          company-dabbrev-downcase        nil
          company-backends                '(company-rtags company-nxml company-css)))


#+END_SRC



#+RESULTS:
: t
** hideshow
#+BEGIN_SRC emacs-lisp
  (use-package hideshow
    :ensure t
    :bind (("C-M-`" . hs-toggle-hiding)))

#+END_SRC

#+RESULTS:
: hs-toggle-hiding
** find other file
#+BEGIN_SRC emacs-lisp
                                            ; Non-nil means ignore cases in matches (see `case-fold-search').
                                            ; If you have extensions in different cases, you will want this to be nil.
    (setq ff-case-fold-search "on")

    (setq ff-always-in-other-window "on")

                                            ; If non-nil, always attempt to create the other file if it was not found.
    (setq ff-always-try-to-create nil)

    ;;   If non-nil, ignores #include lines.
    (setq ff-ignore-include "on")

                                            ; ff-quiet-mode
                                            ;  If non-nil, traces which directories are being searched.

    ;;   A list of regular expressions specifying how to recognize special
    ;;   constructs such as include files etc, and an associated method for
    ;;   extracting the filename from that construct.
    ;; - ff-special-constructs'

                                            ;      Alist of extensions to find given the current file's extension.
    (defvar my-cpp-other-file-alist
      '(("\\.cpp\\'" (".hpp" ".ipp"))
        ("\\.ipp\\'" (".hpp" ".cpp"))
        ("\\.hpp\\'" (".ipp" ".cpp"))
        ("\\.cxx\\'" (".hxx" ".ixx"))
        ("\\.ixx\\'" (".cxx" ".hxx"))
        ("\\.hxx\\'" (".ixx" ".cxx"))
        ("\\.c\\'" (".h"))
        ("\\.h\\'" (".c"))
        ))

    (setq-default ff-other-file-alist 'my-cpp-other-file-alist)

    (setq ff-search-directories '("." "./../export/include/*/*" "./export/include/*/*" "./include/*" ))
    (setq cc-search-directories '("." "./../export/include/*/*" "./export/include/*/*" "./include/*"))
                                            ;    List of directories searched through with each extension specified in
                                            ;   `ff-other-file-alist' that matches this file's extension.


    ;; - `ff-pre-find-hook'
    ;;   List of functions to be called before the search for the file starts.

    ;; - `ff-pre-load-hook'
    ;;   List of functions to be called before the other file is loaded.

    ;; - `ff-post-load-hook'
    ;;   List of functions to be called after the other file is loaded.

    ;; - `ff-not-found-hook'
    ;;   List of functions to be called if the other file could not be found.

    ;; - `ff-file-created-hook'
    ;;   List of functions to be called if the other file has been created.



    (define-key c-mode-map (kbd "M-o") 'ff-find-other-file)
    (define-key c++-mode-map (kbd "M-o") 'ff-find-other-file)

  (if (featurep 'projectile)
     (progn 
       (define-key c-mode-map (kbd "M-o") 'projectile-find-other-file-other-window)
       (define-key c++-mode-map (kbd "M-o") 'projectile-find-other-file-other-window)))


#+END_SRC

#+RESULTS:
: projectile-find-other-file-other-frame
** bookmark in a file
#+BEGIN_SRC emacs-lisp
(use-package bm
  :bind (("<C-f2>" . bm-toggle)
         ("<f2>" . bm-next)
         ("<S-f2>" . bm-previous)))
#+END_SRC
** misc
#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode 1)

  ;; Treating terms in CamelCase symbols as separate words makes editing
  ;; a little easier for me, so I like to use subword-mode everywhere.
  (global-subword-mode 1)

  ;; Compilation output goes to the *compilation* buffer. I rarely have
  ;; that window selected, so the compilation output disappears past the
  ;; bottom of the window. This automatically scrolls the compilation
  ;; window so I can always see the output.
  (setq compilation-scroll-output t)
#+END_SRC
* Programming
** c++
*** ggtags
#+BEGIN_SRC
  (use-package ggtags
    :ensure t
    :config 
    (add-hook 'c-mode-common-hook
              (lambda ()
                (when (derived-mode-p 'c-mode 'c++-mode)
                  (ggtags-mode 1))))
    )
#+END_SRC
*** rtags
#+BEGIN_SRC

(use-package ivy-rtags)
(use-package flycheck-rtags)

(setq rtags-display-result-backend 'ivy)

(define-key c-mode-base-map (kbd "M-.") (function rtags-find-symbol-at-point))
(define-key c-mode-base-map (kbd "M-,") (function rtags-find-references-at-point))
(define-key c-mode-base-map (kbd "M-:") (function rtags-find-file))
(define-key c-mode-base-map (kbd "C-.") (function rtags-find-symbol))
(define-key c-mode-base-map (kbd "C-,") (function rtags-find-references))
;(define-key c-mode-base-map (kbd "C-<") (function rtags-find-virtuals-at-point))
(define-key c-mode-base-map (kbd "M-i") (function rtags-imenu))

(setq rtags-autostart-diagnostics t)
(defun my-flycheck-rtags-setup ()
  (flycheck-select-checker 'rtags)
  (setq-local flycheck-highlighting-mode nil) ;; RTags creates more accurate overlays.
  (setq-local flycheck-check-syntax-automatically nil))
(add-hook 'c-mode-hook #'my-flycheck-rtags-setup)
(add-hook 'c++-mode-hook #'my-flycheck-rtags-setup)
(add-hook 'objc-mode-hook #'my-flycheck-rtags-setup)

#+END_SRC

#+RESULTS:
| my-flycheck-rtags-setup | er/add-cc-mode-expansions | (lambda nil (sb-rtags--menu-adds ObjC)) | (lambda nil (easy-menu-add-item nil (quote (ObjC)) (rtags-submenu-list))) |

*** indentation
#+BEGIN_SRC
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
(c-set-offset 'substatement-open 0)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC
(defun my-c-mode-common-hook ()
 ;; my customizations for all of c-mode, c++-mode
(c-set-offset 'substatement-open 0)


 setq-default c-indent-tabs-mode t     ; Pressing TAB should cause indentation
                c-indent-level 4         ; A TAB is equivilent to four spaces
                c-argdecl-indent 0       ; Do not indent argument decl's extra
                c-tab-always-indent t
                backward-delete-function nil) ; DO NOT expand tabs when deleting
  (c-add-style "my-c-style" '((c-continued-statement-offset 4))) ; If a statement continues on the next line, indent the continuation by 4

  (defun my-c-mode-hook ()
    (c-set-style "my-c-style")
    (c-set-offset 'substatement-open '0) ; brackets should be at same indentation level as the statements they open
    (c-set-offset 'inline-open '+)
    (c-set-offset 'block-open '+)
    (c-set-offset 'brace-list-open '+)   ; all "opens" should be indented by the c-indent-level
    (c-set-offset 'case-label '+))       ; indent case labels by c-indent-level, too
  (add-hook 'c-mode-hook 'my-c-mode-hook)
  (add-hook 'c++-mode-hook 'my-c-mode-hook)

#+END_SRC

#+RESULTS:
*** keybindings
#+BEGIN_SRC emacs-lisp 
   ;; c++ mode debugging
   (global-set-key (kbd "<f6>") 'gdb)
   (global-set-key (kbd "<f7>") 'compile)


  (global-set-key (kbd "<f8>") 'gud-break)
  (global-set-key (kbd "<iso-lefttab-f5>") 'gud-remove)


   (global-set-key (kbd "<f5>") 'gud-cont)
   (global-set-key (kbd "<f9>") 'gud-print)
   (global-set-key (kbd "<f10>") 'gud-next)
   (global-set-key (kbd "<f11>") 'gud-step)
#+END_SRC

#+RESULTS:
: gud-step

** Web Mode
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.vue?\\'" . web-mode))
    (setq web-mode-engines-alist
          '(("django"    . "\\.html\\'")))
    (setq web-mode-ac-sources-alist
          '(("css" . (ac-source-css-property))
            ("vue" . (ac-source-words-in-buffer ac-source-abbrev))
            ("html" . (ac-source-words-in-buffer ac-source-abbrev))))
    (setq web-mode-enable-auto-closing t))
  (setq web-mode-enable-auto-quoting t) ; this fixes the quote problem I mentioned
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2)

#+END_SRC
* Shell
** Better Shell
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package better-shell
    :ensure t
    :bind (("C-'" . better-shell-shell)
           ("C-;" . better-shell-remote-open)))
#+END_SRC
** eshell stuff
#+BEGIN_SRC emacs-lisp

  (use-package shell-switcher
    :ensure t
    :config 
    (setq shell-switcher-mode t)
    :bind (("C-'" . shell-switcher-switch-buffer)
           ("C-x 4 '" . shell-switcher-switch-buffer-other-window)
           ("C-M-'" . shell-switcher-new-shell)))

#+END_SRC
#+RESULTS:
: t
* Elfeed
#+BEGIN_SRC emacs-lisp
  (setq elfeed-db-directory "~/Dropbox/shared/elfeeddb")

  ;; use an org file to organise feeds
  (use-package elfeed-org
    :ensure t
    :config
    (elfeed-org)
    (setq rmh-elfeed-org-files (list "~/Dropbox/shared/elfeed.org")))

  (defun elfeed-mark-all-as-read ()
    (interactive)
    (mark-whole-buffer)
    (elfeed-search-untag-all-unread))

  ;;functions to support syncing .elfeed between machines
  ;;makes sure elfeed reads index from disk before launching
  (defun bjm/elfeed-load-db-and-open ()
    "Wrapper to load the elfeed db from disk before opening"
    (interactive)
    (elfeed-db-load)
    (elfeed)
    (elfeed-search-update--force))

  ;;write to disk when quiting
  (defun bjm/elfeed-save-db-and-bury ()
    "Wrapper to save the elfeed db to disk before burying buffer"
    (interactive)
    (elfeed-db-save)
    (quit-window))

  (defalias 'elfeed-toggle-star
    (elfeed-expose #'elfeed-search-toggle-all 'star))

  (use-package elfeed
    :ensure t
    :bind (:map elfeed-search-mode-map
                ("q" . bjm/elfeed-save-db-and-bury)
                ("Q" . bjm/elfeed-save-db-and-bury)
                ("m" . elfeed-toggle-star)
                ("M" . elfeed-toggle-star)
                ("j" . vmj/hydra-elfeed/body)
                ("J" . vmj/hydra-elfeed/body)
                ))

  (use-package elfeed-goodies
    :ensure t
    :config
    (elfeed-goodies/setup))

  (defhydra vmj/hydra-elfeed ()
    "filter"
    ("c" (elfeed-search-set-filter "@6-months-ago +cs") "cs")
    ("e" (elfeed-search-set-filter "@6-months-ago +emacs") "emacs")
    ("o" (elfeed-search-set-filter "@6-months-ago +mitocw") "mitocw")
    ("*" (elfeed-search-set-filter "@6-months-ago +star") "Starred")
    ("M" elfeed-toggle-star "Mark")
    ("A" (elfeed-search-set-filter "@6-months-ago") "All")
    ("T" (elfeed-search-set-filter "@1-day-ago") "Today")
    ("Q" bjm/elfeed-save-db-and-bury "Quit Elfeed" :color blue)
    ("q" nil "quit" :color blue)
    )

#+END_SRC

#+RESULTS:
: vmj/hydra-elfeed/body

* Transpose lines
#+BEGIN_SRC emacs-lisp

  (defun move-line (n)
    "Move the current line up or down by N lines."
    (interactive "p")
    (setq col (current-column))
    (beginning-of-line) (setq start (point))
    (end-of-line) (forward-char) (setq end (point))
    (let ((line-text (delete-and-extract-region start end)))
      (forward-line n)
      (insert line-text)
      ;; restore point to original column in moved line
      (forward-line -1)
      (forward-char col)))

  (defun move-line-up (n)
    "Move the current line up by N lines."
    (interactive "p")
    (move-line (if (null n) -1 (- n))))

  (defun move-line-down (n)
    "Move the current line down by N lines."
    (interactive "p")
    (move-line (if (null n) 1 n)))

  (global-set-key (kbd "C-M-<up>") 'move-line-up)
  (global-set-key (kbd "C-M-<down>") 'move-line-down)
#+END_SRC

#+RESULTS:
: move-line-down

* Key bindings 
#+BEGIN_SRC emacs-lisp
    ;;Keyboard mappings

    (global-set-key (kbd "\e\ei") (lambda () (interactive) (find-file "~/Dropbox/orgfiles/i.org")))
    (global-set-key (kbd "\e\el") (lambda () (interactive) (find-file "~/Dropbox/orgfiles/links.org")))
    (global-set-key (kbd "\e\ea") (lambda () (interactive) (find-file "~/Dropbox/orgfiles/arts.org")))
    (global-set-key (kbd "\e\en") (lambda () (interactive) (find-file "~/Dropbox/orgfiles/notes.org")))
    (global-set-key (kbd "\e\ec") (lambda () (interactive) (find-file "~/.emacs.d/myinit.org")))
    (global-set-key (kbd "\e\eb") (lambda () (interactive) (find-file "~/Dropbox/orgfiles/books.org")))


    (global-set-key (kbd "<f4>") 'kmacro-end-and-call-macro)
    (global-set-key (kbd "<C-f5>") 'revert-buffer)
    (global-set-key (kbd "C-\\") "\C-a\C- \C-e\M-w") ;copy current line
    (global-set-key (kbd "<C-f7>") 'toggle-truncate-lines)
    (global-set-key (kbd "C-`") 'other-window)
    (global-set-key (kbd "C-o") 'other-window)
    (global-set-key (kbd "<C-iso-lefttab>") 'other-window)
    (global-set-key (kbd "C-<return>") 'jump-to-next-newline)
    (global-set-key (kbd "C-x o") 'swap-window)
    (global-set-key (kbd "<C-f6>") 'mlint-clear-warnings)

    (global-set-key (kbd "C-<") 'beginning-of-buffer)
    (global-set-key (kbd "C->") 'end-of-buffer)

    (global-set-key (kbd "<C-f8>") 'view-mode)

    (global-set-key (kbd "C-;") 'iedit-mode)

  ;; example of binding keys only when html-mode is active

  (define-key dired-mode-map "\C-o"    'other-window)
;;  (define-key  compilation-mode-map "\C-o"  'other-window)


#+END_SRC

#+RESULTS:
: other-window

* edit server & emacs chrome
#+BEGIN_SRC emacs-lisp
  (use-package edit-server
    :ensure t 
    :config
    (when (locate-library "edit-server")
      (setq edit-server-new-frame nil)
      (edit-server-start)))
#+END_SRC

#+RESULTS:
: t

* Engine mode 
Enable [[https://github.com/vmj/engine-mode][engine-mode]] and define a few useful engines.

#+BEGIN_SRC emacs-lisp
  (use-package engine-mode
    :ensure t)

  (defengine duckduckgo
    "https://duckduckgo.com/?q=%s"
    :keybinding "d")

  (defengine github
    "https://github.com/search?ref=simplesearch&q=%s"
    :keybinding "g")

  (defengine google
    "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
    :keybinding "l")

  (defengine rfcs
    "http://pretty-rfc.herokuapp.com/search?q=%s")

  (defengine stack-overflow
    "https://stackoverflow.com/search?q=%s"
    :keybinding "s")

  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w")

  (defengine wiktionary
    "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

  (defengine youtube
    "https://www.youtube.com/results?search_query=%s"
    :keybinding "y")

  (engine-mode t)

#+END_SRC

#+RESULTS:
: t

* ediff
#+BEGIN_SRC emacs-lisp
    (setq ediff-split-window-function 'split-window-vertically)
  (setq ediff-window-setup-function  'ediff-setup-windows-plain)
#+END_SRC

#+RESULTS:
: split-window-vertically

* Writing prose
** Look up definitions in Webster 1913

I look up definitions by hitting =C-x w=, which shells out to =sdcv=. I've
loaded that with the (beautifully lyrical) 1913 edition of Webster's dictionary,
so these definitions are a lot of fun.

#+BEGIN_SRC emacs-lisp
  (defun vmj/region-or-word ()
    (if mark-active
        (buffer-substring-no-properties (region-beginning)
                                        (region-end))
      (thing-at-point 'word)))


  (defun vmj/dictionary-prompt ()
    (read-string
     (format "Word (%s): " (or (vmj/region-or-word) ""))
     nil
     nil
     (vmj/region-or-word)))

  (defun vmj/dictionary-define-word ()
    (interactive)
    (let* ((word (vmj/dictionary-prompt))
           (buffer-name (concat "Definition: " word)))
      (with-output-to-temp-buffer buffer-name
        (shell-command (format "sdcv -n %s" word) buffer-name))))

  (define-key global-map (kbd "C-x l") 'vmj/dictionary-define-word)
#+END_SRC

#+RESULTS:
: vmj/dictionary-define-word

** Look up words in a thesaurus

Synosaurus is hooked up to wordnet to provide access to a thesaurus. Hitting
=C-c s= summons it.

#+BEGIN_SRC emacs-lisp

  (use-package synosaurus
  :ensure t)

    (setq-default synosaurus-backend 'synosaurus-backend-wordnet)
    (setq-default synosaurus-choose-method 'popup)
    (add-hook 'after-init-hook #'synosaurus-mode)
    (global-set-key (kbd "C-c l") 'synosaurus-lookup)
    (global-set-key (kbd "C-c r") 'synosaurus-choose-and-replace)


  (use-package mw-thesaurus
  :ensure t
  :config
  (setq mw-thesaurus--api-key "353fc03f-5f64-4d61-84a5-0e630f1c96ea"))


#+END_SRC

#+RESULTS:
: synosaurus-choose-and-replace

** Editing with Markdown

Because I can't always use =org=.

- Associate =.md= files with GitHub-flavored Markdown.
- I'd like spell-checking running when editing Markdown.
- Use =pandoc= to render the results.
- Leave the code block font unchanged.

#+BEGIN_SRC emacs-lisp
  ;;  (use-package markdown-mode
  ;;    :commands gfm-mode

  ;;    :mode (("\\.md$" . gfm-mode))

  ;;    :config
  ;;    (setq markdown-command "pandoc --standalone --mathjax --from=markdown")
  ;;    (add-hook 'gfm-mode-hook 'flyspell-mode)
  ;;    (custom-set-faces
  ;;     '(markdown-code-face ((t nil)))))
#+END_SRC

** Wrap paragraphs automatically

=AutoFillMode= automatically wraps paragraphs, kinda like hitting =M-q=. I wrap
a lot of paragraphs, so this automatically wraps 'em when I'm writing text,
Markdown, or Org.

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'gfm-mode-hook 'turn-on-auto-fill)
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
#+END_SRC

#+RESULTS:

** Cycle between spacing alternatives

Successive calls to =cycle-spacing= rotate between changing the whitespace
around point to:

- A single space,
- No spaces, or
- The original spacing.

Binding this to =M-SPC= it strictly better than the original binding of
=just-one-space=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-SPC") 'cycle-spacing)
#+END_SRC

#+RESULTS:
: cycle-spacing

** Linting prose

I use [[http://proselint.com/][proselint]] to check my prose for common errors. This creates a flycheck
checker that runs proselint in texty buffers and displays my errors.

#+BEGIN_SRC emacs-lisp
  (require 'flycheck)

  (flycheck-define-checker proselint
    "A linter for prose."
    :command ("proselint" source-inplace)
    :error-patterns
    ((warning line-start (file-name) ":" line ":" column ": "
              (id (one-or-more (not (any " "))))
              (message (one-or-more not-newline)
                       (zero-or-more "\n" (any " ") (one-or-more not-newline)))
              line-end))
    :modes (text-mode markdown-mode gfm-mode org-mode))

  (add-to-list 'flycheck-checkers 'proselint)
#+END_SRC

#+RESULTS:

Use flycheck in the appropriate buffers:

#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook #'flycheck-mode)
  (add-hook 'gfm-mode-hook #'flycheck-mode)
  (add-hook 'text-mode-hook #'flycheck-mode)
  (add-hook 'org-mode-hook #'flycheck-mode)
#+END_SRC

#+RESULTS:

** Enable region case modification

#+BEGIN_SRC emacs-lisp
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+END_SRC
* excorporate
#+BEGIN_SRC 

     (setq-default
      ;; configure email address and office 365 exchange server adddress for exchange web services
      excorporate-configuration
       (quote
        ("vjayakri@mathworks.com" . "https://outlook.office365.com/EWS/Exchange.asmx"))
       ;; integrate emacs diary entries into org agenda
       org-agenda-include-diary t
       )

  (add-hook 'diary-mark-entries-hook 'diary-mark-included-diary-files)

  (defun my/agenda-update-diary ()
    "Update exchange diary."
    (interactive)
    (exco-diary-diary-advice
     (calendar-current-date)
     (calendar-current-date)
     #'message "Diary updated"))

  (add-hook 'org-agenda-cleanup-fancy-diary-hook 'my/agenda-update-diary)
  (excorporate)
  (excorporate-diary-enable)

     ;; ;; enable the diary integration (i.e. write exchange calendar to emacs diary file -> ~/.emacs.d/diary must exist)
     ;; (excorporate-diary-enable)
     ;; (defun ab/agenda-update-diary ()
     ;;   "call excorporate to update the diary for today"
     ;;   (exco-diary-diary-advice (calendar-current-date) (calendar-current-date) #'message "diary updated")
     ;;   )

     ;; ;; update the diary every time the org agenda is refreshed
     ;; (add-hook 'org-agenda-cleanup-fancy-diary-hook 'ab/agenda-update-diary )

#+END_SRC

#+RESULTS:
: Excorporate diary support enabled.
* Malayalam font
#+BEGIN_SRC elisp

(set-fontset-font t 'malayalam "AnjaliOldLipi")
(set-fontset-font t 'malayalam "Manjari" nil 'append)
(set-fontset-font t 'thai (font-spec :script 'thai) nil 'append)
#+END_SRC

#+RESULTS:

* purpose mode
#+BEGIN_SRC 

  (use-package window-purpose
:ensure t)



(add-to-list 'purpose-user-name-purposes '("*compilation*" . comp))
(add-to-list 'purpose-user-mode-purposes '(rtags-mode . tags))
(add-to-list 'purpose-user-mode-purposes '(help-mode . help))
(add-to-list 'purpose-user-mode-purposes '(gud-mode . debug))
;;  (add-to-list 'purpose-user-mode-purposes '(c++-mode . cpp))

(add-to-list 'purpose-user-regexp-purposes '("\.cpp" . source))
(add-to-list 'purpose-user-regexp-purposes '("\.hpp" . header))

(purpose-compile-user-configuration)


#+END_SRC

#+RESULTS:
: ((.hpp . header) (.cpp . source))

* compilation window
#+BEGIN_SRC emacs-lisp

(setq special-display-buffer-names
      '("*compilation*"))

(setq special-display-function
      (lambda (buffer &optional args)
        (switch-to-buffer buffer)
        (get-buffer-window buffer 0)))


(setq compilation-finish-functions
      (lambda (buf str)
        (if (null (string-match ".*exited abnormally.*" str))
            ;;no errors, make the compilation window go away in a few seconds
            (progn
              (run-at-time "0.4 sec" nil
                           (lambda ()
                             (select-window (get-buffer-window (get-buffer-create "*compilation*")))
                             (switch-to-buffer nil)))
              (message "No Compilation Errors!")))))

  ;; (require 'compile)
  ;; (setq compilation-last-buffer nil)

  ;; (defun compile-again (ARG)
  ;;   "Run the same compile as the last time.

  ;; If there is no last time, or there is a prefix argument, this acts like M-x compile."
  ;;   (interactive "p")
  ;;   (if (and (eq ARG 1)
  ;;            compilation-last-buffer)
  ;;       (progn
  ;;         (set-buffer compilation-last-buffer)
  ;;         (revert-buffer t t))
  ;;     (progn
  ;;       (call-interactively 'compile)
  ;;       (setq cur (selected-window))
  ;;       (setq w (get-buffer-window "*compilation*"))
  ;;       (select-window w)
  ;;       (setq h (window-height w))
  ;;       (shrink-window (- h 10))
  ;;       (select-window cur))))
  ;; (global-set-key (kbd "C-x C-m") 'compile-again)
  ;; (defun my-compilation-hook ()
  ;;   "Make sure that the compile window is splitting vertically."
  ;;   (progn
  ;;     (if (not (get-buffer-window "*compilation*"))
  ;;         (progn
  ;;           (split-window-vertically)))))
  ;; (add-hook 'compilation-mode-hook 'my-compilation-hook)
  ;; (defun compilation-exit-autoclose (STATUS code msg)
  ;;   "Close the compilation window if there was no error at all."
  ;;   ;; If M-x compile exists with a 0
  ;;   (when (and (eq STATUS 'exit) (zerop code))
  ;;     ;; then bury the *compilation* buffer, so that C-x b doesn't go there
  ;;     (bury-buffer)
  ;;     ;; and delete the *compilation* window
  ;;     (delete-window (get-buffer-window (get-buffer "*compilation*"))))
  ;;   ;; Always return the anticipated result of compilation-exit-message-function
  ;;   (cons msg code))
  ;; (setq compilation-exit-message-function 'compilation-exit-autoclose)
  ;; (defvar all-overlays ())
  ;; (defun delete-this-overlay(overlay is-after begin end &optional len)
  ;;   (delete-overlay overlay)
  ;;   )
  ;; (defun highlight-current-line ()
  ;; "Highlight current line."
  ;;   (interactive)
  ;;   (setq current-point (point))
  ;;   (beginning-of-line)
  ;;   (setq beg (point))
  ;;   (forward-line 1)
  ;;   (setq end (point))
  ;;   ;; Create and place the overlay
  ;;   (setq error-line-overlay (make-overlay 1 1))

  ;;   ;; Append to list of all overlays
  ;;   (setq all-overlays (cons error-line-overlay all-overlays))

  ;;   (overlay-put error-line-overlay
  ;;                'face '(background-color . "red"))
  ;;   (overlay-put error-line-overlay
  ;;                'modification-hooks (list 'delete-this-overlay))
  ;;   (move-overlay error-line-overlay beg end)
  ;;   (goto-char current-point))
  ;; (defun delete-all-overlays ()
  ;;   "Delete all overlays"
  ;;   (while all-overlays
  ;;     (delete-overlay (car all-overlays))
  ;;     (setq all-overlays (cdr all-overlays))))
  ;; (defun highlight-error-lines(compilation-buffer process-result)
  ;;   (interactive)
  ;;   (delete-all-overlays)
  ;;   (condition-case nil
  ;;       (while t
  ;;         (next-error)
  ;;         (highlight-current-line))
  ;;     (error nil)))
  ;; (setq compilation-finish-functions 'highlight-error-lines)


#+END_SRC

#+RESULTS:
: highlight-error-lines
* Start with scratch buffer always
#+BEGIN_SRC emacs-lisp
  ;; Forces the messages to 0, and kills the *Messages* buffer
  (switch-to-buffer "*scratch*")
  (delete-other-windows)
#+END_SRC

#+RESULTS:
* flycheck and 
#+BEGIN_SRC emacs-lisp
(require 'epa-file)
(epa-file-enable)

(setq flycheck-check-syntax-automatically '(mode-enabled new-line idle-change))
#+END_SRC

#+RESULTS:
| mode-enabled | save | new-line | idle-change |
